# [面试题](https://vue3js.cn/interview/)

# html、css

### HTML5 新特性

```
绘画的 canvas 元素
媒介回放的 video 和 audio 元素
SVG 
语义化标签 ：header、main、footer、aside
拖放属性 :<div draggable="true"></div>
html5修改一些新的input输入特性，改善更好的输入控制和验证：
	calendar、date、time、email、url、search
本地离线存储
```

### css3 新特性

```ts
1.选择器 
	伪类选择器 、 属性选择器 
2.圆角 border-radius 
3.透明度 opacity: 0.1
4.盒阴影  box-shadow
5.弹性盒 display：flex
6.盒模型 box-sizing
	border 和 padding 不会计算 在宽高中
7.过渡 
8.渐变
9.透明度 rgba 
```

### [BFC](https://zhuanlan.zhihu.com/p/25321647)

```
块级格式化上下文

BFC是一块独立的渲染区域，可以将BFC看成是元素的一种属性，拥有了这种属性的元素就会使他的子元素与世隔绝，不会影响到外部其他元素

·设置浮动 float，不包括none
·设置定位（绝对定位或固定定位），absoulte 或者 fixed
·行内块显示模式，inline-block
·设置 overflow，即 hidden，auto，scroll
·表格单元格，table-cell
·弹性布局，flex

特性：
1. 同一个 BFC 下外边距会发生折叠

2.BFC 可以阻止元素被浮动元素覆盖

3.BFC 可以包含浮动的元素（清除浮动）
```

### 回流和重绘

```
回流：

	页面中元素的尺寸，布局，隐藏等改变而需要重新构建页面
	
	1、第一次渲染页面（内容和文字等都发生改变）。
	2、浏览器窗口尺寸的改变。
	3、页面元素（图片，文字）位置和大小尺寸的改变。
	4、新增和删除可见元素。
	5、一些style属性发生变化导致元素变化：（如边框，下划线，css伪类）

重绘：

	页面中元素属性发生改变，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color，则就叫称为重绘

区别：

他们的区别很大：

 回流必将引起重绘，而重绘不一定会引起回流。
 
 比如：	只有颜色改变的时候就只会发生重绘而不会引起回流
 		  当页面布局和几何属性改变时就需要回流
 		  
 比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变
 
 
 
 如何避免和减少回流和重绘
 	1、减少dom和样式的修改，不多次修改样式
	2、样式集中，尽量使用外部样式表和外部js，读写分离，这样有利于服务器和浏览器缓存
	3、能使用css的就不用js操作样式：（每次js操作都会导致重绘或者回流）
	4、页面中多次需要重排的元素，position使用 absolute 或 fixed
	5.尽量不使用表格布局（无定宽高的表格宽高由最后一行决定，绘制到最后一行不合理的时候会反复进行计算回流）
```

### 水平垂直居中有哪些方法

```
1.绝对定位方法：确定了当前div的宽度，设置绝对定位，left为50% ，top为50%， margin值为当前div宽度一半的负值
　div {
        width:600px;
        height: 600px;
        background:red;
        position: absolute;
        left:50%;
        top:50%;
        margin-left:-300px;
        margin-top:-300px;
	 }
	 
2.绝对定位 ：设置绝对定位，上下左右为 0 ，margin ：auto
 
3.弹性盒子
 div {	
 		height:800px;
 		display: flex;
   	 	justify-content: center;
    	align-items:center;
    }
  
  4.绝对定位 + transform （过渡），将 translate 设置为-50% (不知道宽高)
  	div {	
 		position: absolute;    
 		left: 50%;    
 		top: 50%;    
 		transform: translate(-50%,-50%)
    }
  	 
  5.table 布局
  		将父元素设置 display:table-cell 子元素设置 display: inline-block
     
```

### css中实现元素隐藏的几种方法

```
1. display : none

2. visibility : hidden

3. opacity : 0

4. position  :  利用定位将元素的top和left值设为足够大的负数，使它移出屏幕在屏幕上看不见

5. overflow : hidden 

6. z-index: 负值

7. transform: scale(0,0)：将元素缩放为 0

8. height、width 为 0
```

### display:none与visibility:hidden的区别

```
display:none , 元素会被隐藏，不会占空间

visibility:hidden，元素会被隐藏，但还是会占空间
```

### CSS中可继承与不可继承属性有哪些

```js
无法继承：宽、高、padding、margin、border、background、定位

可以继承：font-size、line-height、color、text-align
```


### 定位

```
relative ：相对定位，相对于其原来的位置进行定位

absolute ：相对于没有定位以外的一个父元素进行定位

fixed ：固定定位 ，相对于屏幕视⼝（viewport）的位置来指定元素位置

sticky ：粘性定位
```

### 画一条0.5px的线

```
缩放
transform: scale(0.5,0.5);
```

### 设置元素为浮动后，display的值

```js
设置元素为浮动后，display 的值是 block
```

### px、em、rem、vw/vh 各自代表的含义？

```js
px：绝对单位，页面按精确像素展示

em：相对单位，如果自身定义了font-size按自身来计算,如果自身没有，则以最近父节点字体的大小，整个页面内1em 不是一个固定的值

rem：相对单位，可理解为root em, 相对根节点 html 的字体大小来计算

vh、vw：主要用于页面视口大小布局，在页面布局上更加方便简单
```



# js

### 闭包 ：有权访问另一个函数作用域中的变量的函数

```
特点：

	函数嵌套函数

	函数内部可以引用函数外部的参数和变量

	参数和变量不会被垃圾回收机制回收

优点：避免全局污染 ，保护私有变量 ，延长了变量的生命周期

缺点：处理不当，容易造成内存泄漏

应用：防抖
```

### js垃圾回收机制

```
JS的垃圾回收机制是为了以防内存泄漏

JS有两种变量，全局变量和在函数中产生的局部变量。局部变量的生命周期在函数执行过后就结束了，此时便可将它引用的内存释放（即垃圾回收），但全局变量生命周期会持续到浏览器关闭页面

现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除（mark and sweep）、引用计数(reference counting)。
```



### 浅拷贝、深拷贝

```
基本数据类型：数据存储在栈中。

引用数据类型：数据存放在堆内存中，栈中存放了一个引用地址，指向堆内存中的数据。




浅拷贝是复制,两个对象指向同一个地址

深拷贝是新开栈,两个对象指向不同的地址



浅拷贝：只拷贝对象的引用、而不深层次的拷贝对象的值，引用指向的是同一个对象，多个对象指向 堆内存 中的同一对象，任何一个修改都会使得所有对象的值修改，因为它们公用一条数据

	Object.assign 第一层是深拷贝,第二层是浅拷贝
	
	concat（）
	
	slice（）


深拷贝：将引用类型的值全部拷贝一份，形成一个新的引用类型，在堆内存中重新开辟一个空间，数据发生变化，不会修改原数据

拷贝的是他们的引用地址，数据发生变化，不会修改原数据

	Object.assign()  这种方式第一层是深拷贝,第二层是浅拷贝
	
	ES6扩展运算符

	JSON.parse(JSON.stringify(obj1)); 但是这种方式存在弊端，会忽略undefined、symbol和函数

	函数库 lodash 的_.cloneDeep方法

	递归拷贝
```

### 原型、原型链

```
原型：即构造函数的 prototype 属性，每个函数都有一个 prototype 属性，指向生成该函数的原型对象
原型链：每个对象都有一个 proto 属性,指向生成该对象的原型对象（这样我们就找到了是哪个对象生成了该对象）

原型链一般用于继承，原型链的核心就是依赖对象的 proto 的指向，当自身不存在属性时，就一层层往上找，直到找到 Object.prototype
因为 _proto_ 实质找的是 prototype ，所以我们只要找这个链条上的构造函数的原型（prototype）
```

### 继承:  让一个构造函数去继承另一个构造函数的属性和方法

```
1.原型链继承 ：继承父类构造函数原型上的属性和方法

3.借用构造函数继承

3.组合继承： 原型链继承 和 借用构造函数继承

4.ES6继承方法 ：
	extends 
	super关键字，它指向父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错
```

### this指向

```
全局作用域下，指向 window

函数作用域下：

	非严格模式：指向 window

	严格模式下，为 undefined

对象中，指向当前该对象

普通函数调用 ：指向 window

构造函数调用 ：指向 实例对象

事件绑定的方法：指向 事件的对象

箭头函数 ：箭头函数中没有 this，this指向就是定义时所在的作用域中的 this 值
```

### apply，call，bind

```
apply，call，bind 改变函数运行时的指向，当第一个参数为null或undefind时，指向 window

apply，call 临时改变thi指向一次

apply ： 可以传入数组，第一个参数：要绑定给this的值 第二个参数：参数列表（可以是数组），使用apply方法改变 this 指向后原函数会立即执行，且此方法只是临时改变thi指向一次。

call  ： 传入参数列表，改变函数指向并立即调用，第一个参数要：绑定给this的值，第二个参数必须是单个参数列表，不能是数组

bind  ：不会调用函数，可以改变函数内部指向，返回绑定this之后的函数

	bind方法和call很相似，第一参数也是this的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入，call则必须一次性传入所有参数)，但是它改变this指向后不会立即执行，而是返回一个永久改变this指向的函数。
```

### [apply，call，bind三者的区别](https://zhuanlan.zhihu.com/p/82340026)

```
三者都可以改变函数的this对象指向。
三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为 undefined 或 null，则默认指向全局window。
三者都可以传参，但是apply是数组，而 call、bind 是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入。
bind 是返回绑定this之后的函数，便于稍后调用；apply 、call 则是立即执行 
```

### 图片懒加载原理

```
在可视区域之外的图片默认不加载，随着页面的滚动，图片进入了可视区域的范围，则触发图片的加载显示

在图片没有进入可视区域时，先不给<img>的src赋值，这样浏览器就不会发送请求了，等到图片进入可视区域再给src赋值。

img 的 src 属性 ，初始化img 的时候，src不能是真实的图片地址，把真实地址存放在一个自定义属性中，例如 data-src 来存放
```

### [null和undefind的区别](https://blog.csdn.net/qq_42239440/article/details/107812876)

```
undefined
	1、声明一个变量，但是没有赋值
	2、访问对象上不存在的属性或者未定义的变量
	3、函数定义了形参，但没有传递实参
	4、使用 void 对表达式求值

null
	1.如果定义的变量在将来用于保存对象，那么最好将该变量初始化为null，而不是其他值
	2.当一个数据不再需要使用时，我们最好通过将其值设置为null来释放其引用，这个做法叫做解除引用
	
可以把 undefined 看作是空的变量，而 null 看作是空的对象
```

### == 和 === 的区别

```js
==  只比较它们的值是否相等（会进行隐式转换）

=== 会比较它们的值和数据类型是否相等
```

### 冒泡排序

```
相邻的数据进行两两比较，小数放在前面，大数放在后面，这样一趟下来，最小的数就被排在了第一位，第二趟也是如此，如此类推，直到所有的数据排序完成
```

### [ES6新特性](https://www.jianshu.com/p/9543275de6a3) 

```
1.let、const
2.结构赋值
3.扩展运算符
4.箭头函数
5.Promise
6.Set ：不会出现重复的值
7.Map ：键值对形式
8.async await
9.class类
10.ES6模块化
11.装饰器
```

```ts
1.let、const 和 var 的区别 ：
	var 声明的变量，没有“块级作用域”的限制；
	let / const 声明的变量，具有“块级作用域”。

	var 声明的变量存在“变量提升”，let / const没有。
	let / const 有暂时性死区 ，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是 在声明之前就使用这些变量，就会报错
    
    let / const 不允许重复声明

	let 和 const 的区别 ：const 声明的是常量，不能被修改。
```

```js
2.解构赋值

	如果解构不成功，变量的值就等于 undefined
	解构赋初始值时，如果解构成功，则默认值失效，赋初始值时，严格等于 undefined ，才能赋初始值	
	
    
	1.数组解构赋值
	let [a, b, c, d, e, f] = arr
    
	2.对象解构赋值
    对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
	let obj = {
        a: 1,
        b: [1,2,3],
        c: false,
        d: {name: 'geekxia', age: 10 }
	}
	let { a, b, c, d, e } = obj
    
    3.字符串的解构赋值
    
    4.数值和布尔值的解构赋值
    
    	解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
    
    
    使用场景：
    
    1.交换变量的值
    
    	let a = "hello";
		let b = "world";
    	[a, b] = [b, a];

	2.从函数返回多个值
    	函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便
    3.函数参数的定义
    	解构赋值可以方便地将一组参数与变量名对应起来
    4.提取JSON数据数据 
    	解构赋值对提取JSON对象中的数据，尤其有用
    5.函数参数的默认值
    6.遍历Map结构
    	var map = new Map(); 
		map.set('first', 'hello'); 
		map.set('second', 'world'); 
		for (let [key, value] of map) { console.log(key + " is " + value); }
    7.输入模块的指定方法
    	加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰
    const { SourceMapConsumer, SourceNode } = require("source-map")
```

```js
3.Promise

	Promise 是异步编程的一种解决方案，是一个对象

	Promise 有三种状态：pending (进行中) 、fulfilled （成功）、reject（失败）

	状态改变只有两种可能：pending（进行中） => fulfilled （成功） /   pending（进行中） => reject（失败）

	基本语法：
	
		Promise对象是一个构造函数，用来生成 Promise 实例，接收一个函数作为参数，函数中有两个参数（resole，reject），resole表示成功的回调，reject表示失败的回调，可以在回调后面调用 then（）、cath（）、finally( )
		then（）方法表示成功时的回调
		cath（）方法表示失败时的回调
		finally（）方法表示成功或失败都会执行的回调
```

```js
4.字符串扩展
	1.repeat() repeat 方法返回一个新字符串，表示将原字符串重复 n 次
    参数如果是小数，会被取整
    如果 repeat 的参数是负数或者 Infinity ，会报错
    如果参数是0到-1之间的小数，则等同于0
    参数 NaN 等同于0
    如果 repeat 的参数是字符串，则会先转换成数字
```

```js
5.async await
	async 用来修饰函数，将函数的返回值封装成 Promise 对象
    await 后面跟一个 Promise 对象（如果不是会转换成 Promise 对象），表达式返回 Promise 结果
```



### GET 和 POST 请求的区别

```
1.浏览器回退的时候，GET请求不会重新请求，而 POST 请求会重新请求
2.GET请求会缓存，而 POST 不会
3.GET参数会暴露在地址栏上，相对不安全，而 POST 不会，相对安全
```

### cookie和localstore和sessionstore区别

```
1.存储大小的区别

	cookie数据大小不能大于4K
	
	localStorage 和 sessionStorage则可以达到5M
	
2.时效性

	cookie在设置的有效期内一直有效
	
	localStorage存储持久数据，只要不手动清除则一直存在
	
	sessionStorage数据在当前浏览器关闭后就会被自动清除
	
3.数据与服务器间的交互方式

	cookie的数据会自动传递到服务器端，服务器端也可以写cookie到客户端

	localStorage和sessionStorage不会把数据自动传到服务器端，仅在本地存储
```

### http响应状态码

```
200 成功

300 重定向 
	301 永久重定向（请求资源的URL被永久的改变，新的URL会在响应的Location中给出） 
	302 临时重定向
	304	未修改（协商缓存生效）。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源
	307 临时重定向。与302类似。使用GET请求重定向
	
400 客户端请求有语法错误，不能被服务器所理解
	401 请求未经授权
	403 服务器收到请求，但是拒绝提供服务
	404 请求资源不存在，举个例子：输入了错误的URL。
	405 方法不被允许
	
500 服务器发生不可预期的错误
	503 服务器当前不能处理客户端的请求，一段时间后可能恢复正常
```

### 宏任务、微任务

```js
JS是单线程的，浏览器在执行JS代码时先执行同步任务，再执行异步任务

 **主线程任务——>微任务(promise)——>宏任务(setTimeout)——>宏任务里的微任务——>宏任务里的微任务中的宏任务——>直到任务全部完成**

事件循环 Event Loop

事件循环是 js实现异步的一种方法，也是 js的执行机制。

异步任务包括 宏任务 、 微任务

**宏任务**：

	setTimeout

	setInterval

	主线程任务完成、所有微任务也完成的情况下就会立即执行

**微任务:**

	promise

	process.nextTick(node 独有)
```

### HTTP协议 、3次握手，四次挥手

```
HTTP超文本传输协议，主要作用就是规定浏览器与服务器之间如何通信以及请求响应数据包的格式

三次握手（建立连接的一个过程）
1. 第一次：浏览器首先发送SYN码给服务器，请求和服务器建立连接。
2. 第二次：服务器接收到SYN码后，发送SYN+ACK码给浏览器，告诉浏览器已建立连接。
3. 第三次：浏览器接收ACK码，验证是否正确，若正确就建立数据连接，可以进行数据传输。

需要三次握手才能确认双方的接收与发送能力是否正常。

四次挥手（断开连接的过程）
1. 第一次：浏览器发送FIN码给服务器，告诉服务器，数据传输完成
2. 第二次：服务器接收到FIN码，然后发送ACK码给浏览器，告诉浏览器，你可以断开连接
3. 第三次：服务器，继续发送FIN + ACK码，告诉浏览器我的数据发送完毕
4. 第四次：浏览器接收到FIN码 + ACK码后，同样会发送ACK码给服务器，告诉服务器，我已接收到，你可以断开连接
```

### http 和 https 的区别

```
1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
2、http是超文本传输协议，信息是明文传输，https则是具有安全性的 ssl 加密传输协议。
3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
```

### 防抖（debounce）

```
就是在触发事件后，在 n 秒内，函数只执行一次，如果在 n 秒内，又触发了事件，则会重新计算函数执行的时间

防抖函数分为非立即执行版和立即执行版。

非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。

- search远程搜索框：防止用户不断输入过程中，不断请求资源，n秒内只发送1次，用防抖来节约资源
- 按钮提交场景，比如点赞，表单提交等，防止多次提交
- 监听 resize 触发时，调整浏览器窗口大小会不断触发 resize ，使用防抖可以让其只执行一次
```

### 节流

```
节流，就是指连续触发事件，但是在 n 秒 内只执行一次函数

- 拖拽场景：固定时间内只执行一次， 防止高频率的的触发位置变动
- 监听滚动事件：实现触底加载更多功能
- 屏幕尺寸变化时， 页面内容随之变动，执行相应的逻辑
```

### new 操作符

```
- 创建一个全新的对象
- 这个对象的 __proto__ 属性 要指向 构造函数 的 原型 prototype
- 执行构造函数，使用 call/apply 改变 this 的指向
- 返回值为object类型则作为new方法的返回值返回，否则返回上述全新对象。


（1）创建一个新对象
（2）将对象的__proto__属性指向构造函数的 prototype 属性
（3）将构造函数的作用域赋给新对象（因此this就指向了这个对象）
（4）返回新对象
```

### 描述浏览器输入URL到页面渲染的整个过程

```
浏览器的地址栏输入URL并按下回车；
	DNS 解析：将域名解析成 IP 地址
	生成 HTTP 请求报文
	TCP 连接：TCP 三次握手；（三次握手的目的：为了防止已经失效的连接请求报文段突然又传送到了服务器端，从而产生错误）
	发送 HTTP 请求；
	服务器处理请求并返回 HTTP 报文；
	浏览器解析渲染页面；
	断开连接：TCP 四次挥手。
```

### 白屏

```
js 执行过程中的错误
资源错误
网络延迟，JS加载延迟 ,会阻塞页面

预防 ：
	1.骨架屏
	2.loading
	3.路由懒加载
	4.SSR 服务端渲染
```

### csrf

```
跨站点请求伪造 ，攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求

预防：
	
	1、token验证
	
		由于恶意用户无法窃取cookie，只能利用用户cookie模拟未携带token的http请求，那只要在服务器端进行token验证就可以防御xsrf的攻击。比如我们可以将token存储在localStorage中。
		
	2、验证码
	
		需要用户自己来填写验证码从而识别是否是用户主动发起的该请求。
		其优点：简单粗暴、低成本
		缺点：用户体验不好，需要多次验证。
	
	3、Referer 字段
	
		利用 HTTP 头中的 Referer 判断请求来源是否合法，Referer记录了该 HTTP 请求的来源地址。
	
```

### xss	

```
跨站脚本攻击,代码注入攻击，注入恶意脚本，利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全

预防：
	1、输入过滤
		对用户的输入进行过滤，包括text、post等等所有输入进行可靠性检测。
		也可以制作一个白名单，一但输入中的字符不在白名单内，自动过滤掉。
	2、转义
		与正则的思想类似，对比如<、>等等特殊字符进行转义处理。
	
	1.验证码
	2.服务端渲染开启模板引擎自带的 HTML 转义功能
	3.主动检测和发现，可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞
```

### 数组去重

```
扩展运算符结合set集合  [...new Set(xxx)]
利用 双重for循环 ,结合 splice 方法
利用 filter() 去重 
利用 for 循环 搭配 indexOf 去重
利用 for 循环结合 includes 实现数组去重
```

### for循环 和 forEach循环的区别

```
forEach循环过程中不可以中断，for循环可以使用 关键字 break、return、continue 进行中断
```

### return、break、continue的区别

```
1、return关键字并不是专门用于跳出循环的，return 的功能是结束一个方法。
2、continue只是中止本次循环，接着开始下一次循环。
3、break用于完全结束一个循环，跳出循环体。
```

### 什么是SEO？你有哪些策略实现SEO

```
SEO：搜索引擎优化，让用户更多地找到你
SEO优化的原则：尽量减少js、css功能，尽可能多地使用静态html
SEO策略：官网、移动官网
  数据能用静态渲染，尽量使用渲染
  h1-h6  
  尽量不要都使用div
  html5语义化标签 header footer article nav aside
  meta 元数据、关键词
  title 标签
  加上title属性
  加上图片alt属性
  服务端渲染
```

### 如何给SPA(单页面应用程序)做SEO

```
1.SSR服务端渲染

	将组件或页面通过服务器生成 html，再返回给浏览器，如 nuxt.js

2.静态化

	目前主流的静态化主要有两种：（1）一种是通过程序将动态页面抓取并保存为静态页面，这样的页面的实际存在于服务器的硬盘中（2）另外一种是通过WEB服务器的 URL Rewrite的方式，它的原理是通过web服务器内部模块按一定规则将外部的URL请求转化为内部的文件地址，一句话来说就是把外部请求的静态地址转化为实际的动态页面地址，而静态页面实际是不存在的。这两种方法都达到了实现URL静态化的效果

3.使用 Phantomjs 针对爬虫处理

	原理是通过Nginx配置，判断访问来源是否为爬虫，如果是则搜索引擎的爬虫请求会转发到一个node server，再通过PhantomJS来解析完整的HTML
```

### 浏览器缓存两大策略

```
1. 强制缓存：不会向服务器发送请求，直接命中内存中的缓存资源，从chrome Network中可以看到资源200且from disk cache或from memory cache。

   强制缓存 就是不会向服务器发送请求,而是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程
 

2. 协商缓存：向服务器发送请求，服务器根据request header内的参数来判断是否需要更新此资源，如果不需要更新，服务器返回304的状态码，然后通知浏览器读取本地缓存。

	协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程

总结：强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用强缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，使用则返回304，继续使用协商缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；
```

### 函数式编程

```js
React16.8 和 Vue3.0

函数式编程使得代码单元相比面向对象来说更加独立，在tree shaking（移除 JavaScript 上下文中的未引用代码(dead-code)）过程中更便于打包工具对未使用的代码进行过滤，对项目体积有一定的优化

函数式编程以函数为代码单元，相比于面向对象的方式减少了对this的控制，对于js这种this指向可能会发生改变的语言，一定程度上减轻了开发人员对于this指向问题的困扰

函数式有利于单元测试
```

# Vue

### Vue基本指令

```js
v-if , 当它们的值是false时，元素被移除掉
v-show，当它的值是false时，元素只是通过display:none来隐藏元素

v-if 本质就是 创建和销毁元素
v-show 是通过 display:none css样式来隐藏元素

v-for 和 v-if 的优先级：
	v-for 的优先级更高，如果同时出现在同级每次渲染都会先执行循环再判断条件，由此可见对性能损耗比较大，可使用
	计算属性先筛选需要的数据
```
### v-model 原理 

```
v-bind：value

v-on：事件（input）  手动取值（e.target.value），并赋值

存在问题：v-model 和 value 有一个强绑定关系，如果子组件中有一个 input 原生标签，此时就会影响原生标签的 value 和 input 事件,想要支持多属性的话，需要使用.sync

vue3 统一 使用 v-model 进行多个数据双向绑定，废除了 model 组件选项。
```

### 计算属性、监听器及其二者区别

```
 计算属性 computed
 
    作用：对多个声明式变量进行复杂运算，以减少在指令使用复杂的表达式
    特点：依赖于Vue的响应式系统，自己关联的声明式变量只要不发生变化，不会重新计算，具有缓存作用
    原理：getter、setter 钩子函数

 侦听器 watch
 
    作用：用于监听一个变量的变化，可以监听哪些变量呢？
    
      声明式变量
      计算属性
      路由$route
      
  区别：
  		watch 可以进行异步操作，computed 不行
  		computed 依赖于Vue的响应式系统，具有缓存作用，watch没有
  		
  计算属性默认只有 getter属性，如果需要 setter 属性，改成对象的写法
  
  	computed: {
      fullName: {
        // getter
        get: function () {
          return this.firstName + ' ' + this.lastName
        },
        // setter
        set: function (newValue) {
          var names = newValue.split(' ')
          this.firstName = names[0]
          this.lastName = names[names.length - 1]
        }
      }
    }
  
  watch 如果需要配置其他属性（深度监听），需要改成 对象的形式
  
    watch: {
    	myName(newValue,oldValue){
    		// do someing
    	},
        myNumber: {
            handler(newVal, oldVal) {
                console.log('newVal', newVal);
                console.log('oldVal', oldVal);
            },
            //immediate为true时则立即触发回调函数；如果为false，则和上面的例子一样，不会立即执行回调。
            immediate: true，
            deep：true
          }
      }
```

### methods与computed区别

```js
1、调用方式不同。computed直接以对象属性方式调用，不需要加括号，而 methods 必须要函数执行才可以得到结果。

2、绑定方式不同。methods与compute纯get方式都是单向绑定，不可以更改输入框中的值。compute的get与set方式是真正的双向绑定。

3、是否存在缓存。methods没有缓存，调用相同的值计算还是会重新计算。competed有缓存，在值不变的情况下不会再次计算，而是直接使用缓存中的值。
```

### $nextTick 

```
在下次 DOM 更新循环结束之后,执行延迟回调，获取更新后的 DOM

视图还没更新完，获取不到 dom 节点的信息

原理：Vue的异步更新策略，就是如果数据发生变化，Vue不会立刻更新 DOM，而是开启一个队列，把组件更新函数保存在队列中，在同一事件循环中发生的所有数据变更会异步的批量更新

使用场景：1.created中获取DOM时
		2.响应式数据变化后获取DOM更新的状态，比如 列表更新后的高度

    nextTick 有一个参数 ，是回调函数，作用是，等待 视图更新后，再执行 回调函数中的代码
```

### Vue组件传参

```js
父子组件通信：
	父传子通过props
	子传父通过自定义事件
兄弟组件通信：	
	事件总线 eventbus  是基于一个消息中心，订阅和发布信息的模式 $on  $emit
vuex
跨组件通信：
	provide  / inject	
可以通过 $parent 直接获取到父组件的实例，可以通过 $children 直接获取到子组件的实例
ref
```

### vue的 router 和 route 区别是什么

```
router
	是 VueRouter 的一个对象，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router的实例对象，这个对象中是一个全局的对象，他包含了所有的路由包含了许多关键的对象和属性。
	
$router.push
$router.replace

route
	是一个跳转的路由对象，每一个路由都会有一个route对象，是一个局部的对象，可以获取对应的name,path,params,query等
	$route.path
	$route.params
	$route.name
	$route.query:含路由中查询参数的键值对
```

### Vue路由守卫

```
全局守卫(3)：
	全局前置守卫 beforeEach((to,from,next)=>{}) 、
	全局解析守卫 beforeResolve ((to,from,next)=>{})
	全局后置钩子 afterEach 没有 next（）
路由独享的守卫（1）beforeEnter：（to,from）=>{}
组件内级守卫（3） 
	beforeRouteEnter // 在渲染该组件的对应路由被验证前调用 // 不能获取组件实例 `this`  // 因为当守卫执行时，组件实例还没被创建！
	beforeRouteUpdate 可以访问 this
	beforeRouteLeave
```

### 为什么data属性是一个函数而不是一个对象？

```html
形成一份独立的作用域，不会受到其他实例对象数据的污染，避免变量全局污染
```

### Vue的响应式原理（双向绑定原理）

```
响应式发生在创建阶段，Data中的变量默认是不具备响应式原理的，Vue中 把 data 中的选项进行遍历，使用 Object.defineProperty 进行响应式数据劫持，并把这些转化为 getter/setter  ，将劫持到的数据赋值给当前实例化对象上面，当data中的数据发生变化时触发 getter/ setter（钩子函数），然后通知 watcher，通过 watcher 进行视图更新，视图发生更新进而生成新的虚拟DOM
```

### Vue的生命周期

```
Vue的生命周期，总共有11种，常用的有8种，分为4个阶段，分别是：创建、挂载、更新、销毁阶段，

	开始先实例化，初始化事件及钩子函数，
	
	然后进入第一个阶段，创建阶段，beforeCreate   ---->  created ,响应式原理就发生在这个阶段，具体是通过对Data选项进行遍历，使用object.defineProperty进行响应式数据劫持，并把这些 转化为 getter/setter， 把劫持到的数据赋值到当前实例化对象上，当data中的数据发生变化时触发 getter/ setter（钩子函数），然后通知 watcher，通过 watcher 进行视图更新，视图发生更新进而生成新的虚拟DOM，，可以在创建完成时期（created），进行发请求，传数据，调接口，
	
	创建阶段结束之后，就开始找视图结构，找到视图结构之后，
	
	就进入了第二个阶段（ beforeMount  ----->   mounted）挂载阶段,在这个阶段，创建虚拟DOM对象，然后把虚拟DOM对象替换成真实的数据，完成视图的渲染，挂载完成之后，可以进行调接口，开启定时器，长连接，DOM操作等。
	当声明式变量发生变化时，就进入第三阶段（ beforeUpdate  ---->  updated ）更新阶段，再创建一个新的虚拟DOM，然后运用 diff算法，把新的和旧的虚拟DOM进行比较，找出两者之间变化的最小差异，标记为脏节点，然后 派发（patch） 给 Watcher，通过 Watcher 转化为真实的DOM，完成页面的渲染，只要声明式变量再次发生改变时，就会一直循环。
	
	最后一个为销毁阶段（beforeDestroy  ---> destroyed），在销毁之前，可以关闭定时器，关闭长连接，清除耗费内存的其他变量，最后销毁
	
	动态组件 keep-alive

 		它是Vue内置组件，在Vue系统中可以直接使用

 		作用：被keep-alive所包裹的组件，不会“死”，不会被销毁

 		生命周期：被keep-alive包裹的组件，有两个特殊的生命周期

			activated：当组件被激活时触发

 			deactivated：当组件被停用时触发
 			
 	keep-alive 有三个属性 ：
    
 		include - 字符串或正则表达式。只有名称匹配的组件会被缓存。
		exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。
		max - 数字。最多可以缓存多少组件实例。
```

### 父子组件生命周期执行顺序

```
加载渲染过程：
	父 beforeCreate --  父 created -- 父 beforeMount --子 beforeCreate --子 created --子beforeMount -- 子 Mounted --父 Mounted
```

```
更新过程：
	父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated
```

```
销毁阶段:
	父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed
```

### Vuex工作流程

```
	Vuex在工作中，主要用于解决组件之间数据共享的问题，当我们需要定义共享数据的时候，定义在状态管理的State中，页面中如果发生各种交互行为，需要修改state，我们可以通过Actions或者Mutations方法，当我们需要通过后端调接口时，我们就封装actions方法，在页面（组件）的 Mouted 生命周期或者Created 生命周期中，进行派发并触发（Dispatch）一个 action 方法，并把参数传递过去，得到后端异步数据后，我们在状态管理的Actions中commit（提交并触发）Mutations方法，来修改state，在页面中我们使用...mapState来使用数据，每次state更新，页面自动更新，如果页面中没有涉及到页面数据，只是同步数据，我们直接在页面事件处理器中，通过commit（提交并触发）Mutations方法，来修改state，state发生变化，页面自动更新
```

### Vuex数据持久化原理

```
vuex只是在内存保存状态，刷新之后就会丢失

1.使用插件（vue-persist、vue-persistedstate） 内部实现就是通过订阅（subscriber） mutation变化做统一处理，通过插件的选项控制哪些需要持久化
2.提交 mutation的时候同时存入 localStorage，store中把值取出来 作为state的初始值即可
subscriber 方法
```

### Vue.use()做了什么工作

```js
Vue.use() 是全局注册一个组件或者插件的方法。每次注册前，都会判断一下这个组件或者插件(plugins)是否注册过，如果注册过，就不会再次注册了。

第一，判断这个插件是否被注册过，如果已经注册了，不允许重复注册。如果插件没有被注册过，那么注册成功之后会给插件添加一个 installed 的属性，其值为true。Vue.use方法内部会检测插件的installed属性，从而避免重复注册插件.


第二，接收的plugin参数的限制是 Object | Function 两种类型之一。

1.如果是对象

    该对象里面要有一个 install 方法
    
    Vue.use就是调用里面的 install 方法 ，这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象，用于传入插件的配置

2.如果是一个 function

    Vue.use时 function 会直接执行

作用 ：

	添加全局方法或者属性。如: vue-custom-element

	添加全局资源：指令/过滤器/过渡/组件等。如 vue-touch

	通过全局混入来添加一些组件选项。如 vue-router

	添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现

	一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router
```

### Vue依赖收集

```js
通过 Object.definedproperty,进行响应式数据劫持，来设置观察属性的 setter 和 getter
	
通过 getter 收集依赖，通过 setter 触发依赖更新

get事件在属性没有变化时触发并且还会触发dep收集依赖

set事件在属性发生变化触发并且触发dep收集依赖再触发Watch执行更新
```

### 跨域与浏览器同源策略

```
什么是跨域？

	"协议：//域名：端口"，有任何一个不同就是跨域
	
什么是 浏览器同源策略？

	1.浏览器同源策略，是一种安全机制，它的特点是，阻止Ajax进行跨域（非同源）下的数据请求

	2.同源策略只在浏览器中才起作用，在Node服务器上使用ajax工具跨域请求，是没有任何问题

总结：只有在浏览器中，同源策略才起阻止ajax的跨域请求

如何解决跨域请求的问题？（常用有三种）

		1.JSONP  原理：利用 script 的 src属性，浏览器不会阻止， 只能解决GET请求的跨域问题

		2.CORS   在后端添加 headers 以允许被同源访问(后端配置允许跨域的源)

		3.代理	前端代理、后端 Nginx/Apache代理

前端代理解决 "跨域请求" 的机制是怎样的呢？

		1.让前端业务调接口，访问本地服务器（localhost：8080），如此就不跨域

		2.本地服务器做了代理，当收到前端业务请求时，进行代理转发，相当于是node服务向远程服务器发送请求

		3.node服务向远程发送请求时，跨域了，但是node环境中没有CORS同源策略

在本地开发环境下，可以使用前端代理，当上线后可以使用后端代理
```

### Diff运算的工作流程：（发生在更新阶段）

	1.在挂载阶段，生成一个虚拟DOM,保存在内存中
	
	2.在声明式数据发生变化时（更新阶段），Vue会生成一个新的虚拟DOM
	
	3.使用diff（vm1，vm2），找出两个虚拟DOM之间变化最小差异，将其标记为脏节点
	
	4.接着把脏节点patch到Watcher，使用真实DOM操作api更新视图
### 如何理解虚拟Dom

```
1.虚拟DOM初始生成，发在挂载阶段beforeMoute--->Mouted

2.是一个json对象，是根据真实Dom结构生成的，用于描述真实DOM结构，保存在内存中

虚拟DOM的作用：给DOM更新提供了中间层，避免用户过渡地操作真实DOM，提高web性能

Vue性能高原因：Vue工作每次都会生成一个新的虚拟DOM对象，然后使用diff运算，对比新的和旧的虚拟DOM，找出他们之间的变化的最小差异，再通过真实的DOM操作，把最小差异更新到页面上
```

### BSR 客户端渲染(前后端分离)：视图与数据的组装是在客户端完成的

### BSR的优势和劣势有哪些？

  ```
  前后端分离,代码更容易维护
  数据化应用，交互更加丰富
  前端工程师讲价值更高
  SEO有严重劣势
  在ToB产品上应用更广泛
  ```

### SSR 服务器渲染(前后端不分离)：视图和数据的组装是在服务端完成的

### SSR的优势和劣势有哪些？

  ```
  前后端不分离,对后端的要求非常高
  有利于SEO
  对客户端的压力比较小，服务器压力较大
  在ToC产品上应用比较广泛
  ```

### hash 和 history 区别

```
1.原理不同 ：

	hash：通过监听浏览器的 hashchange（）事件变化，查找对应的路由规则

	history：利用 H5 的 history 中新增的两个API pushState（）和 replaceState（）和 一个 popstate（） 事件 监听URL变化
	
2.history 模式需要后端配合将所有访问都指向 index.html，否则用户刷新页面，会导致 404 错误
```

### require与import的区别

```js
1.两者的加载方式不同，require是在运行时加载，而import 是在编译时加载

2.语法规范不同，require是 CommonJS/AMD规范，import是 ESMAScript6+ 规范
```

### 项目权限管理

```
一般分为 页面权限和按钮权限
方案 ：前端方案、后端方案
```



# Vue3.0新特性

1. ### 响应式原理

   ```
   Vue2.0 响应式 使用 object.defindPrototy，对data上的数据进行遍历，进行响应式数据劫持，然后把劫持到的数据赋值给当前组件实例化对象上面
   	
   	存在的问题：
   	
   		1.对象动态新增属性、删除属性，界面不会自动更新（需要使用$set、$delete）
   
   		2.数组直接通过下标修改数值，界面不会自动更新（需要使用$set，或者splice方法）
   
   		3.必须要遍历所有的数据,还需要重写数组的方法,性能消耗也比较大
   		
   	如何监听数组的变化：
       
   		原理就是重写数组的七个原始方法,当使用者执行这些方法时,我们就可以监听到数据的变化,然后做些更新操作,	
   
   ```

   ```
   Vue3.0 的 响应式（Proxy）
   
   	直接对整个对象进行响应式数据劫持，并返回一个新的对象，就可以直接操作新的对象
   
   	可以直接监听数组的变化（`push`、`shift`、`splice`）
   
   	实现原理:
   
   		通过 Proxy（代理）：拦截对象中的任意属性的变化，包括属性的读写、添加、删除等
   
   		通过 Reflect（反射）：对被代理对象的属性进行操作
   ```

2. ### 性能优化

   ```
   diff算法优化：
   
   	Vue 2.0 是全量比较
   	
   	Vue 3.0 新增静态标记，每次创建虚拟 DOM 的时候，会根据DOM中的内容，是否会发生变化，添加静态标记，只比较有静态标记的
   ```

   ```
   静态提升：
   
   	Vue2.0中，无论元素是否发生变化，每次都会重新创建，然后渲染
   
   	Vue3.0中，对于不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用即可
   ```

   ```
   事件侦听器缓存、复用
   ```

   ```
   SSR(服务端渲染优化） ：
   	当静态内容大到一定量级时候，会用createStaticVNode方法在客户端去生成一个static node，这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染
   ```

3. ### 按需编译、体积更小

   ```
   vite 实现原理：利用 ES6 的 import 会发送请求去加载文件的特性，拦截这些请求，做一下预编译，省去webpack冗长的打包时间
   ```

4. ### Composition API 

   ```
   setup（）函数为  Composition API  的入口，在beforeCreated 之前执行 ，对象中的属性、方法需要 return  出去
   setup（）函数中也可以使用生命周期，setup（）相当于
   ```

   常用的组合式Api

   ```
   setup、ref、reactive、计算属性、侦听器、生命周期、响应式原理、自定义Hooks、toRef、toRefs
   ```

   其他组合式Api

   ```
   shallowRef、shallowReactive、readonly、shallowReadonly、toRaw、markRaw
   ```

5. ### 更好兼容 TS

6. ### 更先进的组件

```
- Fragment 
- Teleport
- Suspense
```

# Vue性能优化

```
1.Vue代码层面的优化

代码层面的优化：

	1.v-if 和 v-show 区分使用场景

	2.computed 和 watch 区分使用场景

	3.	v-for 遍历 ，加 key 值,避免使用 index 作为 key 值

		v-for的同时，避免使用 v-if

	4.长列表性能优化 : Object.freeze() 冻结一个对象,不进行响应式数据劫持

	5.事件销毁

	6.图片懒加载  vue-lazyload

	7.路由懒加载

	8.第三方插件按需引入

	9.优化无限列表性能

	10.服务端渲染 SSR or 预渲染



2.webpack配置层面的优化

	1.webpack 对图片进行压缩

			image-webpack-loader

	2.减少 ES6 转为 ES5 的冗余代码
	
	3.提取公共样式等等
```

### 为什么通常不使用 index 作为 key?

```
使用 index 作为 key 时，可能存在DOM元素没有发生改变，只是顺序发生了改变，但是此时的 key 的值就发生了改变，根据domdiff算法，就会更新所有key变化的DOM元素
```

# React性能优化

```
列表项使用 key 属性
使用碎片

函数式组件中：
	使用 React.memo 高阶函数包装组件，React.memo 可以实现类似于 shouldComponentUpdate 或者PureComponent 的效果
	使用 useMemo 精细化的管控，useMemo 控制的则是是否需要重复执行某一段逻辑，而React.memo 控制是否需要重渲染一个组件
	使用 useCallBack ，返回一个函数
	useMemo，返回的的是一个值
	在列表需要频繁变动时，使用唯一 id 作为 key，而不是数组下标。
	必要时通过改变 CSS 样式隐藏显示组件，而不是通过条件判断显示隐藏组件。
	使用 Suspense 和 lazy 进行懒加载
```

# React

### jsx

```
如何理解JSX？
 1、JSX = JavaScript XML，这是一种语法糖
 2、JSX语法，是可选的，但是 React建议使用
 3、JSX语法，浏览器不支持，使用@babel/preset-react进行编译。Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。
 4、JSX元素，是对象，也是变量，是表达式，不是字符串
 5、JSX可以任意嵌套，语法是使用 { } 包裹jsx元素
 6、JSX中使用 {/* 注释内容 */}
 7、在JSX中，可以使用表达式（表达式也要使用{}包起来），但不能使用语句
 8、JSX元素的动态属性，也要使用 {} 包裹
 9、在JSX中有三个属性的变化：className，htmlFor, tabIndex
 10、在JSX中，新增属性有：key，ref，dangerouslySetInnerHTML
 11、JSX可防注入攻击(XSS)
 12、自定义组件必须以大写字母开头。
 13、JSX支持属性展开语法 <Child {...obj} />。
 14、布尔类型、Null 以及 Undefined 在JSX中会被忽略，不能当作文本进行渲染
 15、JSX是不可变对象，当JSX元素需要更新时，我们的做法是创建一个新JSX对象，render方法将重新执行并完成DOM渲染（背后的运行机理：this.setState()修改声明式变量，一旦声明式变量发生变化，React系统会生成新JSX对象，对应生成新的虚拟DOM，进而触发Diff运算，找出两个虚拟DOM变化的最小差异，最后把这个最小差异render到DOM上）


 React类(组件) ==实例化后==》JSX元素(React元素)

 TestJsx 是React类（组件）
 <TestJsx/> React元素（JSX元素）
 
 
 
  jsx是  JavaScript XML，这是一种语法糖，是 react 推荐使用的语法
  jsx浏览器默认不支持这种语法，需要使用 @babel/preset/react 进行转译，背后会使用 react.createElement（）这个函数进行调用，转译成浏览器能识别的语法
  jsx 是不可变对象，当jsx需要更新时，react会重新生成一个新的jsx对象，render方法将重新执行并完成DOM渲染（背后的运行机理：this.setState()修改声明式变量，一旦声明式变量发生变化，React系统会生成新JSX对象，对应生成新的虚拟DOM，进而触发Diff运算，找出两个虚拟DOM之间变化的最小差异，最后把这个最小差异 render 到DOM上）
  jsx 动态属性需要使用 花括号 {} 包裹 ，类选择器需要使用 className
  自定义组件必须以大写字母开头
  JSX支持属性展开语法 <Child {...obj} />
  布尔类型、Null 以及 Undefined 在JSX中会被忽略，不能当作文本进行渲染
  
 
```

### state

```
如何定义state？只能在构造器中定义。

如何进一步理解state？
1、state是声明式变量，它被 this.setState()修改时，react 会生成一个新的jsx对象，对应会生成一个新的虚拟DOM，并触diff运算，找出他们之间变化的最小差异，通过 render 重新渲染，最终更新DOM视图。
2、state的定义发生构造器中，但是在构造器中不能使用this.setState()
3、要想改变视图，一定要使用this.setState()来修改state。
4、在React中，可以直接修改state，但是这不会触发diff运算，因此视图不会更新。
5、重要原则：当我们修改state时，要考虑新值是否由旧值计算而来，如果是建议使用this.setState(fn)的方式进行修改；如果不是，可以使用this.setState({})
6、this.setState()这个方法是异步的。但是在定时器内部(宏任务)使用this.setState()时，它却是同步的。(微任务==》异步    宏任务==》同步)
7、this.setState({}, fn)，当setState()这个异步操作完成时，第二回调函数会执行，在其中可以拿到最新的state（ 类似于VUe的监听器 ）。
8、当多个this.setState()一起调用时，会被React自动合并成一个setState()操作，触发一次diff运算，一次render()。
9、this.setState()在修改声明式变量时，是一种浅合并。某个声明式变量被修改，不会影响其它声明式变量。
10、state是当组件实例的私有数据，state数据可向子元素传递，而不能向父元素传递，这被称为“React单向数据流”。


state 是声明式变量，要定义在构造器中

在React中，可以直接修改state，但是这不会触发diff运算，因此视图不会更新，要想改变视图，一定要使用 this.setState() 来修改state，但是在构造器中不能使用 this.setState()

当使用this.setState()修改声明式变量时，react 会生成一个新的 jsx对象，对应会生成一个新的虚拟DOM，然后触发 diff 运算 ，并找出他们之间变化的最小差异，通过 render 重新渲染，最终更新DOM视图。

this.setState()这个方法是异步的，但是在定时器内部(宏任务)使用 this.setState()时，它却是同步的。(微任务==》异步    宏任务==》同步)

重要原则：当我们修改 state 时，要考虑新值是否由旧值计算而来，如果是建议使用 this.setState(fn) 的方式进行修改；如果不是，可以使用this.setState({})，this.setState({} || fn ，fn )，第二个参数为一个函数，在其中可以拿到修改的，最新的 state（ 类似于VUe的监听器 ）

当多个this.setState() 一起调用时，会被 React 自动合并成一个 setState() 操作，触发一次diff运算，一次render()。

this.setState()在修改声明式变量时，是一种浅合并。某个声明式变量被修改，不会影响其它声明式变量。

state是当组件实例的私有数据，state数据可向子元素传递，而不能向父元素传递，这被称为“React单向数据流”
```

### 如何进一步理解props

```
1、在React开发中，props的作用远远比state更强大
2、在类组件和函数式组件中，都默认有props
3、props是父子组件之间的通信纽带
4、props是不能修改的，因为 React 函数式组件使用的是 纯函数（唯一的输入，唯一的输出，入参不能修改）一个函数的返回结果只依赖于它的参数，并且在执行的过程中没有副作用，我们就把该函数称作纯函数
5、props可以传递任何数据类型，还可以传递事件函数和JSX元素、组件
6、props和state不能交叉赋值，它们没有任何关联
7、最新的React中，props验证是由一个第三库prop-types来实现的
```

### state 和 props 的区别

```
1. state 可以 通过 setState 或 useState 进行修改，而 props 是外部传入的数据，不能修改

2. props的功能非常强大，可以传递任何数据类型，还可以传递事件函数和JSX元素、组件

3. react一个重要的开发原则 ：一切外部数据都要经过 props 传递进来
```

### 生命周期

```
三个阶段 ：
	1.装载阶段：
	React组件实例化时，调用constrouctor（）
		 在这个生命周期中，不能使用this.setState()-
		 在这个生命周期中，不能使用副作用（调接口、dom操作、定时器、长连接）
		 不能把props和state交叉赋值
	componentDidMount() 
		 相当于是vue中的mounted()
		 它表示DOM结构在浏览器中渲染已完成
		 在这里，可以使用任何的副作用（调接口、定时器、DOM操作、长连接。。。）
		 在这里，可以使用this.setState()
	render()
		 是类组件中唯一的一个必须要有的生命周期
		 这个render函数必须要有return，return结果只要满足jsx语法都可以。
		 它的return返回jsx默认只能是单一根节点，但是在Fragment的语法支持下，可以返回多个兄弟节点。
		 Fragment碎片的写法：<React.Fragment></React.Fragment>，简写成<></>
		 在return之前，可以做任意的业务逻辑（但不能使用this.setState()）
		 每当this.setState修改声明式变量时，会触发diff运算，进而触发render()重新渲染。
		 render()这个生命周期，在装载阶段和更新阶段都会运行。
		 当render()返回null时，不影响生命周期的正常运行。
	2.更新阶段（2）
		shouldComponentUpdate()
		 它相当于是一个开关，如果它返回true则更新机制正常执行，如果返回false则更新机制停止.
		 在vue中是没有的，所在React面试经常问题。
		 它存在的意义：可以用于性能优化。但是基本上用不到，最新的解决方案是使用PureComponent。
		 理论上这个生命周期的作用是：用于精细地控制声明式变量的更新问题，如果被变化的声明式变量参与了视图渲染则返回true；如果被变化的声明式变量没有直接或间接参与视图渲染则返回false，以减少diff运算。
		render()
		componentDidUpdate()
			 相当于是vue中的updated()
             它表示DOM结构渲染更新已完成，只发生在更新阶段
			 在这里，可以执行大多数的副作用，但是不建议
             在这里，可以使用this.setState()，但是必须要有终止条件判断，避免死循环。
     3.销毁阶段
        componentWillUnmount()
		 相当于是vue中的beforeDestroy()
		 一般在这里清除定时器、长连接等其它占用内存的变量
		 在这里一定不可以使用this.setState()
```

### 类组件与函数式组件有什么区别

```
类组件，要用 class 关键字来定义，它有state状态，有生命周期、有this，有ref，有上下文。类组件的缺点是相对于函数式组件来说，运行速度相对较慢、性能较差。

 函数式组件，默认啥都没有(除了props)，也就是说默认没有类组件那些特性。函数式组件的好处是运行速度较快，性能更好。（使用 Hooks(v16.8)可以模拟出像类组件一样的众多特性）
 
 类组件使用要实例化，而函数组件直接执行取返回结果即可
```

### 表单绑定（React表单是单向绑定的）

```html
 1、受控表单：指的是表单的 value/checked 属性由 state 控制 ，绑定 onChange 事件，手动取值

 2、非受控表单：指的是表单的value/checked属性不由state控制。

  原则：在React开发中尽可能地都使用受控表单，但是有一个例外，就是文件上传<input type="file"/>
```

### 状态提升（是一种数据共享的理念）

```
 要解决的问题：多个组件之间数据共享的问题。
 怎么做？具体的做法是，找到这几个组件的最近的父组件，把需要共享的状态数据定义在父组件中。
```

### 组合 vs  继承

```js
组合和继承，都是 组件复用 的一种思想（方式）, 但是 React 官方推荐使用 组合模式 来实现组件的复用。

组合的语法基础是：props.children 和 render props（自定义属性可以传递 React元素（jsx元素））

在父组件中间 插入标签 ，子组件直接使用 props.children 进行渲染

render props ==> props 可以传递任何数据类型，还可以传递 事件函数 和 JSX元素、组件(*),子组件可以直接通过 props 进行调用


如果使用“继承”思想，如何复用组件？思路如下：
	class QfModel extends React.Component {}  // 基类
	class QfDeleteModal extends QfModal {}    // 删除类型Modal
	class QfConfirmModal extends QfModal {}
	class QfDeleteSmallModal extends QfDeleteModal = {}
```

### conText(上下文)

```html
 作用：自上而下地向组件树中注入数据 （数据共享）

 注意：在上下文的消费者（实际上就是那些被上下文包裹的组件）中不能修改上下文

 怎么使用上下文呢？

 1、使用 React.createContext() 创建上下文对象

 2、使用上下文对象上的 <xxx.Provider value={xxx}></Provider> 组件，向React组件树注入数据

	<ThemeCtx.Provider value={theme}>
        <Layout />
	</ThemeCtx.Provider>

3、使用上下文对象上的 <xxx.Consumer>{()=>()}</xxx.Consumer> 组件，使用上下文数据
 
     <ThemeCtx.Consumer>
         {
             theme => (
                 <div style={{background:theme.background,color:theme.color}}>
                     <h1>测试上下文</h1>
                 </div>
             )
         }
      </ ThemeCtx.Consumer>

 上下文在哪些第三库中会用到呢？React-Router，Mobx，Redux
```

### 高阶组件

```html
 高阶组件是一种 代码逻辑复用 的高级技巧，结合了 React 的组合特性，在很多第三方库 路由、mobx、redux 中有用到，也叫高阶函数，本质上是一个函数（纯函数）

 	作用：高阶组件（也被称之为容器组件），是用来修饰、装修UI组件的，实现业务逻辑的复用。
              
    语法详解：高阶组件（高阶函数）接受一个 UI组件（React类） 作为入参，返回一个新的UI组件（React类）

	export default WrapComponent => {
        return props=>(
            <WrapComponent
                {...props}
                dialog={dialog}
                img={img}
            />
        )
    }
    
    注意点: 当一个UI组件被多个高阶组件修饰时，props会丢失，需要使用 ...props，保留高阶组件修饰后的 props

	语法：hocFn(UIComponent){return <NewUIComponent {...this.props}>} 属性继承
    
    使用原则：一个高阶组件，一般只复用一个可以复用的逻辑。
    
    类组件中可以使用 装饰器语法
		
```

### 如何创建 refs

```
refs是提供一种访问在render方法中创建DOM节点或者React元素的方法，在典型的数据流中，props是父子组件交互的唯一方式，想要修改子组件，需要使用新的props重新渲染它，某些情况下，在典型的数据流外，强制修改子代，这个时候可以使用refs

我们可以在组件添加一个ref属性来使用，该属性是一个回调函数，接收作为其第一个参数的底层DOM元素或组件挂载实例

通过React.createRef（）创建的，并通过ref 属性附加到react元素，在构造组件中，

通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们

import React, { createRef } from 'react';

const caseDetailRef = createRef(); 

caseDetailRef.current?.xxx

对Dom元素的焦点控制、内容选择、控制
对Dom元素的内容设置及媒体播放
对Dom元素的操作和对组件实例的操作
集成第三方 DOM 库
```

### Hooks （React 16.8 新增）

```
useState
 作用：用于定义声明式变量，模拟类组件中的 state
 语法：const [msg, setMsg] = useState('')
 useState在定义声明式变量时，一定要赋初始值
 useState定义的声明变量，要使用 set*系列方法去更新，不建议直接修改

 useEffect
 如何理解副作用？你可以这么理解，只要不是生成JSX的业务代码，都可以认为是副作用
 副作用包括定时器、调接口、长连接、DOM操作、第三库的初始化等
 作用：模拟类组件中生命周期的特性
 语法：useEffect(()=>{return ()=>{}}, [])
 useEffect 可以看做是 componentDidMount，componentWillUnmount 和 componentDidUpdate  这三个函数的组合
 
 useEffect 有两个参数 ，第一个参数为一个函数 （相当于生命周期里面的 componentDidMount ）这个函数里面还可以 return 一个函数（这个 return 的函数相当于 componentWillUnmount），第二个参数为一个数组，相当于 componentDidUpdate ，（可以把相关联的声明式变量放在里面，每当变量发生变化。就会重新执行）
```

### 常用 Hooks

```
useState
useEffect
useContext
useMemo 计算属性
useCallback
useRef
	const inputRef = useRef<any>(null);
	inputRef.current.blur()

useCallback 的返回值是函数，所以适合对组件的事件响应函数进行处理，避免每次执行都生成新的函数，进而导致子组件属性不同而重新渲染。

useMemo 因为返回值是任意值，所以可用用来做高耗时操作的缓存处理，比如组件需要的一些子组件，比较耗时的纯数值计算等。

简单概括就是：useCallback 用来处理事件函数，useMemo 用来缓存 DOM
```

### 路由 Hooks

```
useParams：获取参数（内部封装）
useHistory：通过js api操作路由跳转 push方法
useLocation: 查看当前路由
useRouteMatch: 挂钩尝试以与<Route>相同的方式匹配当前URL。在无需实际呈现<Route>的情况下访问匹配数据最有用。
```

### Redux Hooks

```
用于 替代 connect 这个高阶组件
useSelector 相当于 mapStateToProps 
useDispatch 相当于 mapDispatchToProps 
```

### Hooks使用需要注意什么？

```js
1.版本： 16.8 新增的特性

2.只能在函数式组件中使用

3.只能在函数组件的最顶层使用hooks，而不能在for循环、if等语句下面使用hooks
	因为函数组件中可以使用useState声明多个state，hooks的状态管理依赖于数组，hooks重新渲染的时候依赖于固有的顺序，如在for循环、if等语句下使用hooks就有可能在重渲染时改变hooks的固有顺序，导致bug。这与hooks的实现原理有关系。
```

### 如何避免组件的重新渲染？

```
React.memo() 这可以防止不必要地重新渲染函数组件

PureComponent 这可以防止不必要地重新渲染类组件

这两种方法都依赖于对传递给组件的props的浅比较，如果 props 没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。
```

### Mobx

![](https://mobx.js.org/assets/flow2.png)

```
状态管理（数据管理）
 Flux（是一套数据架构的思想）是 Facebook 提出的
 Vuex、Mobx、Redux它们都是 Flux 思想指导下的一种具体的解决方案
 状态管理工具：可预测状态的数据容器。

 在React技术栈：mobx 和 redux

 一般情况下，小项目可以考虑使用 mobx 6 & mobx-react 7
 如果是大项目，建议使用 redux & react-redux

 原则：在React规范中，一切外部数据都要从props进入组件，所以几乎是一定要使用状态管理工具。
 
 如何使用： 
 
 从 mobx-react 中，引用 Provider
 
 在App根组件中，使用<Provider store={store}} /> ，注入 store
 
 在React组件中，使用 inject('要使用的store中的数据')(observer(props=>(<div></div>)))
 
 
 - 以下mobx(v6) + mobx-react(v7) 用ES6语法、函数式组件为例，说明集成mobx架构的一般步骤：
  - 1、安装mobx(v6)，用面向对象语法编写store和子store的代码逻辑，参见store目录。
  - 2、安装mobx-react(v7)，在App根组件中，使用<Provider {...store} />
  - 3、在React组件中，使用 inject('stort')(observer(props=>(<div></div>)))
 

 先使用 observer（） 将组件变为观察者，然后再使用 inject （）注入需要共享的数据
 
 语法：inject('store')observer((UIComponent))

 observer(UIComponent) 它的作用是把React组件变成观察者。
 特点：当mobx中被观察的数据发生变化时，观察者自动更新。

 inject('store')(UIComponent) 它的作用是注入mobx中的状态数据
 特点：一旦注入成功，在props上就可以直接访问。
```

```js
// 【[mobx6]定义子Store第一种写法】 makeAutoObservable

import { makeAutoObservable } from 'mobx'

// makeAutoObservable(this) 作用是把当前对象上的成员属性变成observable变量，把成员方法变成action方法。

export default class UserStore {
  constructor() {
    makeAutoObservable(this)
  }
  token = 'token'
  changeMsg(payload){
    this.token = payload
  }
}
```

```js
// 【[mobx6]定义子Store第二种写法】 
// makeObservable  根据开发者的需求，把指定的成员属性变成observable变量，把成员方法变成action。
// 当在action中需要用到同步的async/await时，建议使用 flow，编写generator的语法。
// observable 它用于把一个变量变成可观察的，当它变化时，在观察者中可以自动更新
// action 表示把一个方法变成action，它可以直接修改observable变量
// computed 用于get操作，是计算属性，当它所关联的observable变量发生变化时，会重新计算
import { makeObservable, action, computed, observable } from 'mobx'
export default class TodoStore {
	constructor() {
		makeObservable(this, {
			msg: observable,
			changeMsg: action,
			length: computed,
			list: observable,
			updateList: action
		})
	}
	msg = 'hello mobx 2'
	changeMsg(payload) {
		this.msg = payload
	}
	get length(){
        return this.msg.length
    }
}
```

### React中的组件间通信

```
- 父子组件通信 props
- 自定义事件
- 使用 context 上下文
- 使用 mobx、redux 状态管理
- 状态提升 
```

### create-react-app 设置代理

```
1.在 package.json 中 直接配置 proxy字段

2.下载中间件 http-proxy-middleware 
在 src 目录下，新建 setupProxy.js 文件
```

### redux

![image-20220726174306123](https://redux.js.org/assets/images/one-way-data-flow-04fe46332c1ccb3497ecb04b94e55b97.png)
![](https://redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif)

```
redux 用于定义 store 的

react-redux 提供高阶组件（connect） 和 Hooks 写法 ,用于把 react 和 redux 连接起来
```

```js
Redux 一个可预测状态的数据容器，它是基于Flux思想而开源的项目

第一个3，指的是三个api：createStore / combineReducers / applyMiddleware

	createStore 用来创建 store
    combineReducers 用来合并多个 reducers
    applyMiddleware 使用中间件

 第二个3，指的是Redux工作流程中的三个核心概念，分别 Store、 Action(Dispatch)、 View
 
 第三个3，指的是Store的三个特点：Store单一数据源、Store是只读的、Store 只能通过 Reducer 纯函数进行修改
 
 技术栈：Redux / React-Redux / Redux-Thunk / Redux-Saga ....
```

三个 Api :  createStore( )  /  combineReducers( )  / applyMiddleware( )

```js
import { createStore } from 'redux'
createStore( reducer,{},middleware(中间件)) 创建 store
combineReducers({}) 合并多个 reducer纯函数
import xxx from xxx
const rootReducer = combineReducers({
	study,
	count,
	music,
	user,
	article
})
const store = createStore(
	rootReducer,
    applyMiddleware(thunk)
 )
export default store
```

#### connect 高阶组件写法

```
使用 createState（reducer）创建 Store ，然后 在 react-redux 中 引入 Provider 组件，引入 Store，并在 Provider 组件上注入 Store  ，然后继续在 

react-redux 引入高阶组件 connect 

connect 语法 ：connect（fn1 ，fn2）（UIComponent）
	
	fn1，fn2  两个都要返回一个对象

	connect（mapStateToProps ，mapDispatchToProps）（UIComponent）

mapStateToProps 和 mapDispatchToProps 两个都要返回一个对象

mapStateToProps 的形参 是一个 store ， // 把状态管理中的 state 映射到 props 上 ，然后就可以在 props 上进行访问

mapDispatchToProps 的形参是一个 dispatch 

```

```js
// 把状态管理中的 state 映射到 props 上 ，然后就可以在 props 上进行访问
const mapStateToProps = store =>{
	return {
		msg : store.msg
	}
}

const mapDispatchToProps = dispatch =>{
	return {
		changeMsg : ()=>dispatch ({})
	}
}

页面使用

export default connect(mapStateToProps ,mapDispatchToProps)(UIComponent)
```

reducer 纯函数，用于修改 store 数据

```js
let initState = {
	msg : 'hello redux'
}

// reducer 是一个纯函数，唯一的输入得到唯一的输出
// 在 redux 中 ，只能使用 reducer 来修改 store（state）
// 深入理解 action ，它只能是一个 Plain Object（一个对象，可以被深复制的）。它只能通过 diapatch （action={}），派发到 Store 中
function reducer( state = initState,action ){
    // 因为 store 是 只读的，所以要进行深复制
	let newState = {...state}
    switch (action.type){
        case '':
            // do something
            break;
        default:
           // do something 
    }
    return state
}

const store = createStore( reducer )

export default store
```

#### redux Hook 写法，可以用来代替 connect 这个高阶组件

 ```js
import { useSelector, useDispatch } from 'react-redux'

// 相当于 mapStateToProps
const msg = useSelector(store=>store.study.msg)
// 相当于 mapDispatchToProps
const dispatch = useDispatch()

dispatch(msgChange('hello world'))
 ```

#### redux-thunk 中间件


```js
在 redux 中，dispatch 是同步的，它负责向 store 中派发 plain action object 

redux-thunk 用于解决 redux 不支持异步 actions的问题 

redux 只支持同步的 action ，需要使用中间件（redux-thunk 或者 redux-saga）解决异步 action 

用于异步的 生成器， 必须要 return 一个函数，然后用 redux-thunk

redux-thunk 这个中间件，在 View - Store 之间起作用，它用于判断 action 是不是 函数（fn）, 如果是就构建一个 plain object ，发送给 store

redux，实际上发生了 两次 dispatch  ，第一次 redux 什么都没做，第二次才是真正后端数据放入 redux 中 
```


```JS
const store = createStore( reducer , applyMiddleware ( thunk ) )
```

#### 当需要使用多个 中间件时

```js
import { compose } from 'redux'
const store = createStore( 
    reducer , 
    compose( applyMiddleware ( thunk ), applyMiddleware ( xxx )) 
)

compose 解决 使用多个中间件时，嵌套过多的问题
	
	applyMiddleware ( thunk )( xxx )

	applyMiddleware 返回本身
```
#### 中间件（Middlewa)

```
其本质上一个函数，对 store.dispatch 方法进行了改造，在发出 action 和执行 reducer这两步之间，添加了其他功能

redux-thunk：用于异步操作
redux-logger：用于日志记录
```

### 代码分割

```js
loadable 是一个函数

import loadable from "@loadable/component"

const TestJsx = loadable(()=>import('./study/TestJsx'))
```

### React Fiber --- React 背后的算法

```js
React 15 中的 virtualDOM，这是旧的协调算法

React Fiber 是 React 16 中新的协调算法

react fiber是通过 requestIdleCallback 这个api去控制的组件渲染的“进度条”

react 无法精确更新，所以需要react fiber把组件渲染工作切片
```

### [react diff 算法 的原理是什么](https://vue3js.cn/interview/React/diff.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88)

```
传统diff算法通过循环递归对节点进行依次对比，然后判断每个节点的状态以及要执行的操作，效率低下，算法复杂度达到 O(n^3)，react将 diff算法 进行一个优化，复杂度降为O(n)

React中使用「三个层级策略」对传统的diff算法进行了优化

主要遵循三个层级的策略：tree层级、component层级、element层级

	Tree层级：DOM节点跨层级的操作不做优化，只会对相同层级的节点进行比较，只有删除、创建操作，没有移动操作
	
	Component层级：同一个类的组件，会继续往下diff运算，更新节点属性,如果不是一个类的组件，那么直接删除这个组件下的所有子节点，创建新的
	
				  如果确切知道该组件可以不用更新，可以使用react生命周期函数 shouldComponentUpdate() 方法进行判断优化，阻断不必要的 render
	
	Element层级：同层级的单个节点进行比较，（对于比较同一层级的节点们，每个节点在对应的层级用唯一的key作为标识）用唯一的 key 作为标识，通过 key 可以准确				地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置
	
```

tree层级:

![](https://pic2.zhimg.com/80/v2-2fd15c716c2590813f8c9526cbc7aae5_720w.webp)

components层级:

![](https://pic2.zhimg.com/80/v2-01d30547c443b095e0a7764d25433295_720w.webp)

# [vue的diff算法与react的diff算法的区别](https://blog.csdn.net/CanTest/article/details/114655116)

### vue的diff算法

```
在对新旧虚拟dom进行比较时，是从节点的 两侧向中间 对比；如果节点的 key值 与 元素类型 相同，属性值不同，就会认为是不同节点，就会删除重建
```

### react的diff算法

```
在对新旧虚拟dom进行比较时，是从节点的 左侧 开始对比，就好比将新老虚拟dom放入两个栈中，一对多依次对比；如果节点的 key值 与 元素类型 相同，属性值不同，react会认为是同类型节点，只是修改节点属性


react diff算法也有明显的不足与待优化的地方:

	应该尽量减少将最后一个节点移动到列表首位的操作
	
	当一个集合把最后一个节点移动到最前面，react会把前面的节点依次向后移动，而Vue只会把最后一个节点放在最前面，这样的操作来看，Vue的diff性能是高于react的
```

### 两种diff算法的相同点

```
都只进行同级比较，忽略了跨级操作；常见的现象就是对数组或者对象中的深层元素进行修改时，视图层监测不到其变化，故不会对dom进行更新，需调用一些特质方法来告诉视图层需要更新dom
```



# dva

```
对 redux 做了一些封装，提供了 6 个重要api，把很多路由 redux 逻辑封装起来

app.use() 配置 hooks 或者 插件（插件最终返回的是 hooks）

app.model() 注册 model

app.unmodel()

app.replaceModel()

app.router()

app.start()

作用：

	1.通信问题
	
	2.数据流
	
dva = React-Router + Redux + Redux-saga
```

# umi

```
基于dva， 对 react 做了 2次封装 ，开箱即用，插件繁荣

umirc.ts 或者 config/config.js 为配置文件

哪些情况下不适合：

	react 16.8 以下
	node 10 以下
	有很强的的 webpack 自主观念，自定义 webpack配置
    自定义路由方案
 
应用：ant design pro
```



# Vue 和 React 的区别

### 1.模板渲染方式的不同

```js
React是通过 JSX 渲染模板

Vue是通过一种 拓展的HTML语法 进行渲染
```

### 2.组件逻辑复用的方式不同

```
Vue 使用 mixins（混合）

React 使用 Hoc（高阶组件：高阶组件本质上是一个函数，函数内部返回一个组件)
```

### 3.vue是双向绑定的响应式系统，数据发生变化，视图自动更新，而react是单向数据流，没有双向绑定,需要使用this.setState修改才能触发 diff 运算 ，视图更新

### 4.**组件通信的区别** 

```
Vue中使用 provide/inject 实现跨组件的数据传递
React 中使用 context（上下文）实现跨组件的数据传递 
```

```js
数据流向的不同。react从诞生开始就推崇单向数据流，而Vue是双向数据流

数据变化的实现原理不同。react使用的是不可变数据，而Vue使用的是可变的数据

组件化通信的不同。react中我们通过使用回调函数来进行通信的，而Vue中子组件向父组件传递消息有两种方式：事件和回调函数
diff算法不同。react主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。Vue 使用双向指针，边对比，边更新DOM
```

# 谈一谈vue和react的区别？

```
（1）从编程范式的角度讲



 - 在vue-loader、vue-template-compiler的支持下，vue可以采用SFC单文件组织的方式实现组件化；vue有指令，使用指令能够方便地渲染视图，vue表单是双向绑定的；vue组件是基于选项式的编程，常用选项有生命周期、计算属性、侦听器等；vue的组件库十分繁荣，自定义属性、自定义事件、自定义插槽是vue组件化的三大基础。众多社区中的vue轮子，在vue架构中被Vue.use注册即可使用。



 - react的语法基础是JSX，react中没有指令，元素渲染、条件渲染、列表渲染、动态样式都是基于JSX语法的。在webpack环境中，要安装@babel/core、@babel/preset-react等，实现对JSX的编译。React表单是单向绑定的，推荐使用受控表单。组件封装可以是类组件，也可以函数式组件，其中props是React组件化的核心。



 （2）从组件通信的角度讲



 - 在vue组件通信中，跨组件通信的手段极其丰富且灵活，常用的通信方案有父子组件通信、ref通信、事件总线、provide/inject、parent/children、listeners/attrs、slot插槽通信等。除此之外，在vue中还可以使用vuex 或 mobx 来实现跨组件通信。总体上来讲，vue的组件通信极其灵活，自上而下、自下而上都是容易实现的；也正是因为过于灵活，这会“诱惑”开发者容易滥用通信手段，导致vue项目呈现出“易开发、难维护”的现状。



 - 在react中数据是单向数据流，在组件树中数据只能自上而下地分发和传递。state是组件自有的状态数据，props是父级组件传递过来的数据。在react中最最基本的通信方案是状态提升，还有React上下文也可以实现自上而下的数据流。鉴于react这种数据流的特性，即使集成了Redux仍然会呈现出单向数据流的特征，因此React数据流更容易被管理，配合Redux一起更适合做中大型的项目开发。



 （3）从底层原理的角度讲



 - vue支持指令是因为背后有vue-template-compiler这个编译器的支持，把带有指令的视图模板转化成AST抽象语法树，进一步转化成虚拟DOM。vue的响应式原理是使用了 Object.defineProperty 进行了数据劫持，数据劫持发生vue组件的创建阶段，vue的响应式原理和mobx状态管理的响应式原理相似，这种响应式实现最早出现在 knockout 框架。如果要手写一个简单版本的vue，需要实现Compiler类（用于模板编译）、Watcher类（用于更新视图）、Dep类（用于依赖收集）、Observer类（用于数据劫持）、Vue类（构造函数）等。



 - react自v16以后发生了很多变化，v16以后底层的“虚拟DOM”不再是简单JSON数据了，React采用了最新的Fiber（双向链表）的数据结构，作为“协调”（Diff）运算的基础数据。React背后还提供了强大的 react-reconciler 和 scheduler 库实现Fiber链表的生成、协调与调度。相比vue组件，react在较大组件方面的性能更高。如果要手写一个简易版本的React，其核心要实现以下功能，createElement（用于创建元素）、createDOM/updateDOM（用于创建和更新DOM）、render/workLoop（用于生成Fiber和协调运算）、commitWork（用于提交）等，如果还有支持Hooks，还得封闭Hooks相关的方法。



 （4）从社区发展和未来展望的角度讲



 - vue生态繁荣，用户基础大。vue3.0和vite的诞生给vue生态增加了新的生命力，同时也给vue开发者带来了空前的挑战。vue3.0众多新特性，以组合API、更友好地支持TS为代表，使得vue3.0的写法更加灵活。上手vue3.0并不难，但，要想写出健壮的可维护性更强的vue3.0代码，并不容易，这需要广大的前端开发者有更强大的前端基础功，对MVVM有深刻的理解和沉淀。



 - react生态稳步向前，背后有强大的Facebook开发团队，从类组件编程向Hooks编程的转化指明了前进的方向。React(v18)呼之欲出，让前端开发者对React更具信心。在国内，阿里系的React开源项目繁荣，给以开发者足够的信心，至少三五年内深耕React仍然大有可为。

```

# BEM

```html
是 块（block）、元素（element）、修饰符（modifier）的简写

block 代表了更高级别的抽象或组件。
block__element 代表 .block 的后代，用于形成一个完整的 .block 的整体。
block--modifier 代表 .block 的不同状态或不同版本。
	例如按钮状态 ：  
		&--primary {background: blue;}
        &--success {background: green;}
```

# webpack

```js
如何理解  webpack？

1.它是一个构建工具，是众多流行脚手架的首要选择，也是一个打包器，作用是把前端模块编译成浏览器能识别的HTML + CSS +JS

2.在 webpack 眼中，一切皆模块

3.有四个核心概念 ： 
	入口 entry   : 指定打包的入口文件
    出口 output  : 指定打包后的文件名、文件路径（加 chunkhash 值，解决“代浏览器缓存”导致用户端代码不更新的问题）、自动清除旧的打包目录等
    	loader   : 用于定义模块编译的规则，在 module 中的 rules 中定义 有两个选项 test 和 use 有先后顺序，先执行的要放在后面
    	一些常用的loader：
        	babel-loader：匹配到 .js/.jsx文件 ，利用babel 中的 preset 将语法转换成浏览器能识别的 语法
			style-loader：把css样式添加到 DOM 树中
			css-loader  ：加载 .css 文件
            less-loader ：用于加载 .less 文件，交给 less 编译器进行编译，less编译器会把 .less文件编译成 .css 文件
			sass-loader：用于加载 .sass 文件，交给 sass编译器进行编译，sass编译器会把 .scss文件编译成 .css 文件
		loader 的背后，常常需要安装对应的编译器（js--》babel ，sass，less）来编译对应的文件
   
     plugin ：解决loader无法实现的其他事
    
     	一些常用的 plugin ：
        
        	HtmlWebpackPlugin（用于把打包后的js文件自动插入到index.html中）
			HappyPack （开启多线程babel编译构建）
            ESLintWebpackPlugin(ESLint)

	配置绝对路径 （@）：
	resole 里面有个选项叫 alias 
    省略后缀文件: extensions
    
4.webpack 可以做哪些事：1.构建开发环境 、2.上线打包


Webpack是一个构建工具（rollup、gulp），是众多流行脚手架的首要选择。
* Webpack是一个打包器（打包工具）：入口  => 过程1 => 过程2  => [...] => 出口
* 在Webpack的眼中，一切文件皆模块（这些模块有助于提高前端开发效率）
* Webpack使用各种loaders和plugins，把各种模块编译打包成浏览器能识别的静态资源。





@babel （javaScript 编译器）:

	1. 预设（Presets）用于大版本语法编译
		// 将 ES6 语法转换成 ES5 语法
  		@babel/preset-env
		// 将 jsx 语法转换成浏览器能识别的语法
  		@babel/preset-react
		// 将 ts 语法转换成浏览器能识别的语法
  		@babel/preset-typescript
	2.插件（plugins） 弥补 Presets 无法编译某些细节语法
                                             
                                             
                                             
                                             
   webpack是前端工程化一个很重要的构建工具，是众多脚手架的首要选择，同时也是一个打包器，作用就是把 前端模块 编译成浏览器能识别的 html、css、js 文件
   
   在 webpack 眼中，一切皆模块
                                             
   有四个重要核心概念 ：分别是 entry、output、loaders、plugins
   
   entry（入口，必须要有） ：可以在这里配置 入口文件
   
   output（出口，必须要有）：可以在这里配置 打包后的path（文件路径） 、filename（文件名，加 chunkhash ），clearr ：true（打包后自动清除旧的打包文件）
                                             
   loaders ：用于定义模块编译规则的 在 module 中 的 rules 中 配置规则 test 和 use 字段
             用于加载各种各样的文件模块，并使用相应的编译器对这些模块进行编译
                                             
   常用的 loaders 有 ：babel-loader 、vue-loader、less-loader、sass-loader、css-loader、style-loader
   	babel-loader是干嘛的呢？ babel 是 JavaScript 编译器，主要用于语法编译的，他有两个核心概念：
      presets（预设）和 plugins （插件）
                                             
      presets（预设）是用于大版本编译的 ：
           例如 jsx语法，浏览器识别不了，就需要使用 @babel-preset-react，背后会使用 react.createElement()这个函数
               ts语法使用 @babel-preset-typescript 进行编译
               Es6语法使用 @babel-preset-env 将ES6语法转译成ES5语法
               Vue语法使用 vue-loader ，然后配合 VueLoaderPlugin  插件
                                             
      plugins（插件）弥补 presets 无法编译的细节语法：例如 装饰器语法 
    
   	less-loader ：项目中配置使用 less ，需要安装两个依赖：less-loader、less
      less-loader主要是用于 加载 .less文件的,然后交给 less编译器 进行编译，less编译器会把 .less文件编译成 .css文件 
   	css-loader   用于 加载 .css文件
   	style-loader 用于 将 css样式 添加到DOM树中
                                             
  	当 use 多个loader时，有先后顺序，先起作用的 loader 要写在后面                 
    	use: ['style-loader', 'css-loader', 'sass-loader']                                         
                                             
   plugins的作用是 ： 解决loader无法实现的其他事情
                                             
		html-webpack-plugin ：用于把打包后的js文件自动插入到index.html中           
                                             
        eslint-webpack-plugin ：配置eslint            
                                                                         
		webpack-bundle-analyzer ：打包分析工具 
     
                                             
 除了这 4 个核心配置之外，还有一些其他配置：
     
   	mode ：'development' 用于指定环境 development(开发环境) 、 production（生产环境）
  
	devtool: 'inline-source-map', // 解决控制台报错时“行号对不住”的问题，如果不添加该选项，浏览器控制台也会出现黄色警告
        
    devServer 开发环境的配置，可以配置 热更新、端口、是否、自动打开浏览器、定静态资源目录、代理等等
    	devServer: {
            port: 8080,
            // 开启热更新（HMR = hot module replacement）
            // 热更新，只对main.js往后的依赖才起作用
            // 实际上，开启一台socket服务器，当代码发生变化时，通知客户端socket进行更新
            hot: true,
            open: true,
            // 用于指定静态资源目录（本地服务器）
            contentBase: path.resolve(__dirname, '../public'),
            // 当程序报错时，把错误信息覆盖到视图层之上
            overlay: true,
            proxy: {
                '/soso': {
                    target: 'https://c.y.qq.com',
                    changeOrigin: true
                }
            }
        },
    
   resolve 配置 
   		alias ：用于配置 绝对路径 （@）
		extensions ：用于省略后缀文件
```

# vite

```

vite 基于原生模块 ES Modules 实现

Vite 需要 Node.js 版本 14.18+，16+

```

# [vite和webpack的区别](https://juejin.cn/post/6923417451333959694)

```
Vite 先启动服务，按需加载(并不会先编译所有的代码文件)

Webpack 则是先全部打包,再启动服务 (webpack dev server)

webpack 这类工具的做法是将所有模块提前编译、打包进bundle里，换句话说，不管模块是否会被执行，都要被编译和打包到bundle里。随着项目
越来越大，打包后的bundle也越来越大，打包的速度自然会越来越慢

vite 实现原理：利用 ES6 的 import 会发送请求去加载文件的特性，拦截这些请求，做一下预编译，省去webpack冗长的打包时间
```

# TypeScript

```js
TypeScript是JaveScript的超集

核心：

	1.除了有 JaveScript 的一些数据类型之外，新增了很多额外的数据类型
	
		基本：元组、枚举、any、void
		高级：Never 、 Object
		元组：本质上就是长度固定且每个元素的数据类型也固定的数组(元组不能越界，越界会报错)
		any：任何类型
		void类型：表示没有类型
		枚举类型：类，最好大写
		Never：不存在的值的类型
		函数重载：方法名相同，参数类型、参数个数、函数返回值三者有一个不同，就是重载
		接口（interface）： 定义一个接口（对象、函数的类型（形状））
		泛型（generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性
		接口可以继承一个类
		
	2.更加完整的面向对象编程
	
		特点：封装、继承、多态（多种形态）
		
		修饰符 ：

			public 所修饰的属性或方法，在其他类中可以被正常访问

			private 所修饰的属性或方法，在其他类中是不能被访问的

			protected 所修饰的属性和方法，只能在子类中被访问
			
			readonly 只读属性关键字，只允许出现在属性声明或索引签名中。

		抽象类 : abstract 用于定义抽象类和其中的抽象方法
		
			不允许被实例化,不能 new
			
			抽象类中的抽象方法必须被子类实现
			
		类实现接口 : 把共有的特性，提取成接口（interfaces），用 implements 关键字来实现
		
		一个类可以实现多个接口
		
		接口继承接口
		
		接口继承类
		
		
		
泛型约束 : 在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法

interface Lengthwise {
  length: number
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
  console.log(arg.length)
  return arg
}
```

# 微前端

```js
概念：
	微前端（Micro-Frontends）是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。各个前端应用还可以独立运行、独立开发、独立部署
    
作用：
	拆分和细化
    	将这些庞大应用进行拆分，并随之解耦，每个部分可以单独进行维护和部署，提升效率。
    整合历史系统
    	微前端可以将这些旧系统进行整合，在基本不修改来逻辑的同时来同时兼容新老两套系统并行运行
        
主工程加上一些子工程


iframe

Single-Spa

Qiankun
```

### typescript 中的 interface 和 type 区别

```

相同点:
	
	都可以描述一个 对象 或者 函数 的类型
	
不同点:

	type 可以声明 基本类型别名，联合类型，元组等类型 ,而 interface 不行
	
	interface 支持 同名合并，type 不支持。
	
	type 能使用 in 关键字生成映射类型，但 interface 不行。
```



# 小程序

### 登录流程

```
在 onLaunch （）生命周期 中使用 wx.login( ) 获取 code（有效时间5分钟） ，使用 wx.request( )，调接口 发送code ，用code换取token，...（后端），后端返回 token ，前端拿到 token存储在 storage ，以后每次发起业务请求 ，携带 token，后端再检查 token  ，最后返回业务数据

小程序获取地理授权

```

![image-20220721165248784](C:\Users\李伟斌\AppData\Roaming\Typora\typora-user-images\image-20220721165248784.png)

![image-20220722160615654](C:\Users\李伟斌\AppData\Roaming\Typora\typora-user-images\image-20220722160615654.png)

![image-20220722160840373](C:\Users\李伟斌\AppData\Roaming\Typora\typora-user-images\image-20220722160840373.png)

![image-20220722162919382](C:\Users\李伟斌\AppData\Roaming\Typora\typora-user-images\image-20220722162919382.png)

打包 ：点击工具栏 ==》发行==》原生app打包（安卓）

配置名字、证书（安装 JRE8 ）

https://ask.dcloud.net.cn/article/35777



umi 基于 dev



# 微信公众号

```
实际上就是可以使用 jssdk（wxsdk）的 H5页面

技术栈 ：
	HTML + CSS + JQ
	Vue移动端
	React移动端
	
1.订阅号（适用于个人）
	
	一天能群发一条消息

2.服务号（适用于企业、政府或其他组织）

	一个月只能发送四条消息
	
```

![image-20220824105329805](C:\Users\李伟斌\AppData\Roaming\Typora\typora-user-images\image-20220824105329805.png)

# Git

### git rebase 和 git merge 的区别

```
git rebase 和 git merge 都是 Git 用来 合并分支代码 基本命令

git rebase 和 git merge 一样都是用于从一个分支获取并且合并到当前分支


使用 git merge，进行两条分支的合并,将两个分支的历史联系在一起，会产生一个额外的合并提交记录

使用 git rebase 会将整个分支移动到另一个分支上，有效地整合了所有分支上的提交，不会产生额外的合并提交记录
```



token过期在响应拦截器里面 重定向到 登录页

ant design 表单双向绑定，如果为 <Radio /> ,则需要在 <Form.Item>组件上定义 valuePropName = 'checked'



在请求拦截器中，在 localstorage 中获取 token





### 移动端 300ms 延迟事件处理方法

```
安装 FastClick 插件
```





# 国际化

```
引入 i18n 

引入对应语言包
```



# node

```js
基于谷歌V8引擎的 jsvescript 运行时环境
事件驱动
非阻塞的IO
```

express

```js
先安装 express
cnpm i express -S

//创建服务器
var express = require('express')
var app = express( )

// 读取静态资源
app.use(express.static('public'))

//请求
app.get('/*',function(req,res){
    res.json({err:0,msg:'succuese'})
})

//监听服务
app.listen(9002,function(){
	//
})
```

路由

```js
var express = require('express')

var router = express.Router()

router.post('/login',function(){
    //接收入参
    //如果是 GET 请求，入参放在 req.params 中
    //如果是 POST 请求，入参放在 req.body 中
    //返回給前端
    res.json({err:0,msg:'succuese'}) 
})

module.export = router
```

路由页面使用

```js
var userRouter = require('./router/user')

// 使用中间件
//第一个参数为 前缀 ，第二个为 模块
app.use(‘/api/user’，userRouter)
```







# [MongoDB](https://www.bilibili.com/video/BV1C64y1M7sz?p=2&vd_source=b181f0930217866823e6f6e0f6f1be8e)

```
在命令行 启动 mongod （路径为 mongodb目录下的data目录 ）
mongod --dbpath "F:\mongodb\data"

另开一个命令行，验证是否启动成功
mogo    //如何打印版本信息则成功

然后 
show dbs
```

### [mongo shell](https://github.com/geekxia/node-stack)

```js
//进入数据库 
use xxx
// 查看当前运行端口 
db.getMongo()

// 增
db.xxx.inserOne()
db.xxx.inserMany()
// 删
db.xxx.deleteOne()
db.xxx.deleteMany()
// 查
db.xxx.find() // 查出所有
db.xxx.find().count().then(()=>{}) // .count()获取 total
db.xxx.findOne()
db.xxx.findById()
db.user.find().limit(5)  //只查询前5条记录
db.user.find().skip(10)  //查询10条以后的所有数据
db.user.find().skip(5).limit(5)  //查询第6~10条记录
// 改
db.xxx.updateOne({},{$set:{}})
db.xxx.updateMany({},{$set:{}})


```

在项目中使用，写接口

```
cnpm i mongoose -S
```

连接	数据库

```js
// connect.js
const mongoose = require('mongoose')
//连接数据库中的 gp5
mongoose.connect('mongodb://localhost:27017/gp5',{
    useNewUrlParser:true,
    useUnifiedTopology:true
})

const db = mongoose.connection

//验证是否成功
db.once('open',()=>{
    console.log('连接成功')
})

db.on('error',()=>{
    console.log('连接失败')
})
```

在页面中直接 require 进来就行

```js
require(./connect.js)
```

编写增删改查接口

```js
var express = require('express')
// 引入 mongoose
var mongoose = require('mongoose')
//增删改查操作的对象是集合

//定义一个 Schema
var userSchema = new mongoose.Schema({
    user: String,
    age : Number,
    class:String
})
// 第一个参数为 表的名字（一定要是复数）,第二个为 Schema
var userModel = mongoose.model('users'，userSchema)

var router = express.Router()

//定义 GET 请求接口
router.get('/list',(req,res)=>{
    // 从 req.query 中 ,取出 GET 请求的 入参
    let { page，size } = req.query
    page = parseInt( page || 1 )
    size = parseInt( size || 10 )
    userModel.find().skip((page-1)*size).limit(size).then(docs=>{
        	// 查询成功 ，以 json形式 返回給前端
        	res.json({err:0,msg:'succuese',data:docs})
        }).catch(err=>{
        
    	})
    })
})

//定义 POST 请求接口
router.post('/add',(req,res)=>{
    // 从 req.body 中 ,取出 post 请求的 入参
    let { user，age } = req.body
  	// 存入数据库
    userModel.insertMany([{user,age}]).then(docs=>{
        	// 查询成功 ，以 json形式 返回給前端
        	res.json({err:0,msg:'添加用户成功'})
        })
    })
})

module.export = router
```



![image-20220730012953156](C:\Users\李伟斌\AppData\Roaming\Typora\typora-user-images\image-20220730012953156.png)



### [express项目搭建](https://www.expressjs.com.cn/starter/generator.html)

```
npm install -g express-generator

express --view=ejs myapp
```

### [koa](https://koa.bootcss.com/)

```js
中间件
	在http请求和响应中间的处理程序
    	koa-router
		koa-body
		koa-static

洋葱圈模型
	递归原理
	
ctx.request.query  可以简写为  ctx.query
ctx.request.body   可以简写为  ctx.body

错误处理：
	1.没有通过 ctx.body 返回数据时，koa默认会帮你返回 404 错误
	2.ctx.throw
	3.500，运行时错误，自动抛出错误
    4.中间件 koa-json-error 
```



# BMap

```
1.注册
2.申请密钥
3.在 index.html中，以 cdn 方式引入，加密钥
4.设置容器，设宽高
5.new 地图实例
```



### 区分开发环境和生产环境

```
1.
	cnpm i cross-env -D 
	cnpm i webpack-merge

```

babel-loader  加载  js 文件

@babel/core 进行编译转译





# 小程序

```js
1.下载微信开发者工具
2.加入到小程序管理后台中的项目成员中，有登录的权限

需求：
	Tabbar
    Navbar
    登录 wx.login() 
	授权地理定位 scope.useLocation
	获取用户信息、手机号
    小程序支付 wx.requestpayment() 在小程序后台接入公司已有的微信支付账号
	转发、下拉刷新、触底加载
    路由跳转、路由传参
    常用组件：swipe、picker、scroll-view

打包上线:

	代码体积：
    	1.分包技术
        2.图片的使用（icon类小图片不需要加速、UI界面类一定要加速）
    
    各类通讯接口：
    	1.api请求
        2.websocket
        3.文件上传
        4.文件下载
    
     
        
```





# uniapp

```
第三方登录：

	调用 uni.login({}) api ,传入对应的参数 ，拿到 openid


支付：

	调用 uni.requestPayment
	

# uniapp简介

- uniapp：跨平台技术（一套前端代码，打包成多个平台的应用）
- uniapp：各种小程序、android app、ios app、快应用、webapp(h5)等等。
- 现在呈现的市场趋势是：很多中小型公司用uniapp做android app。（uniapp做小程序的公司比较少）

- 2018年9月，uniapp开源了（发布了）。

- 开发特点：一种是vue2风格、另一种是vue3风格（2021年8月左右）。


# 微信小程序开发

- 原生的微信小程序开发（四种文件）
- Wepy微信小程序官方的小程序框架：https://wepyjs.github.io/wepy-docs/2.x/#/
- mpvue做微信小程序：http://mpvue.com/

- Taro(v3)（react风格）
- uniapp(vue2风格)

# Uniapp知识点（文档是最好的学习资源）

- 会安装HbuilderX软件（App版本）、会使用这个软件工具。
- 会创建uniapp项目（参考官网）不建议使用命令行创建。
- 要知道项目中每个文件的作用（manifest.json这个文件特别重要，切换vue版本）。

- 安装Vuex（在uniapp中已经内置了，自已会配置目录文件、编写vuex代码）
- 理解uniapp基于配置的特点（类似微信小程序风格），比如会配置tabBar、navigator。。
- 跨平台条件编辑：https://uniapp.dcloud.io/platform

- 组件使用：uniapp内置组件、h5标签、第三方UI组件（比如uni-ui、uview-ui）。。。
- 集成sass（在uniapp官网上注册开发账号，在HbuilderX登录、在插件市场中找到sass进行安装）
- 使用 uView 组件
  - uView官网：https://www.uviewui.com/
  - 样式导入：https://www.uviewui.com/components/downloadSetting.html

- 小程序调试：提前安装好各种小程序开发者工具，把HBX中运行好的代码导入到开发者工具中即可。

- 华为手机驱动：https://www.hihonor.com/cn/support/suite/
- 小米手机驱动：http://www.mi.com/c/service/download
- 苹果手机驱动：https://support.apple.com/kb/DL1816?viewlocale=zh_CN&locale=zh_CN
  - 手机上的“开发者设置”要打开！

- 混合开发
  - 打开一个具体的APP，哪些页面是混合的（前端做的）样式复杂、长页面；如果这个页面有文件上传之类的表单，不建议使用混合。
  - App和混合页面是怎么通信的？从App到混合页面使用查询参数，从混合页面向App通信使用postMessage()。

- App打包（以android为例）
 - 要在dcloud平台注册一个公司账号、实名备案、创建一个uniapp的应用（得到uniapp appid）。
 - 把uniapp中各种url改成线上真实的路径（如果有图片资源需要处理，也要注意图片的问题）
 - 生成app证书：安装java se8环境（配环境变量），使用keytool生成签名证书。
 - 打包前，在manifest.json（界面视图、源码视图），添加Logo、勾选当前uniapp中用到的功能模块、权限列表。
 - 如果当前uniapp中还用到了第三方工具（地图、支付、天气预报），也都是在manifest.json中进行权限配置。
 - 如果当前uniapp中还用到了dcloud官方的付费功能，都也要在manifest.json中配置。。。
 - 在HBX中选中项目，点击“发行->原生App打包”，按照要求填写信息，进行原生打包。
 - 在HBX中，点击“发行->查看App打包状态”，可以得到.apk包的下载地址。

```

# Taro

```

# Taro简介

- Taro：是一个跨平台的技术栈===>微信小程序、支付宝小程序、头条小程序、ReactNative（安卓App、IOS App）、QQ轻应用、WebApp（H5）

- Taro呈现的发展趋势：中小型用Taro做微信小程序。

- 2020年8月：之前的版本是Taro(v2)只支持React语法风格；之后迭代成Taro(v3)版本，支持vue(2)(3)、React、ReactHooks风格。

- Taro优势：支持跨平台开发（一套代码可以打包成多种不同的应用程序）、Taro大大地降低了小程序开发的成果。
- Taro劣势：虽然支持跨平台，但要写很多兼容性代码，导致代码臃肿、可维护性不高；Taro中技术更新比较滞后。


# Taro生态

- 为什么要学习Taro？因为很多中小型公司在用Taro做微信小程序。还有一个原因是Taro非常适合学习（Taro可以搭建出很多种不同风格架构、编程风格）。
- 两个UI构架：NutUI(v3)、TarUI(v2)
  - NutUI(v3)只支持taro-vue3的开发风格
  - TarUI(v2)对taro-react风格不太友好（应该用不了），建议提前使用 taro-ui@next。
- 两个框架：NervJS(京东内部研发的MVVM框架)、preact(迷你的React框架)。
  - nervjs：https://nerv.aotu.io/
  - preact：https://preactjs.com/
- 京东小程序。
  - 和微信小程序几乎差不多。

```



```
外网面板地址: http://119.23.211.60:8888/202e2e45
内网面板地址: http://172.17.56.118:8888/202e2e45
username: fbtnbmcx
password: 3283cb5f

```

# Electron

```markdown

- 跨平台技术：做桌面应用 Electorn  / NW.js
- Electorn 本质上是 Node.js + 谷歌浏览器的内核，所以它可支持election代码逻辑，还可以渲染Web页面。
- 桌面应用技术栈：Electorn是壳子，在这个壳子里面可以使用任意的web前端技术（jQuery/Vue/React/Angular）
- 虽然Electron中有浏览器的内核，但没有CORS同源策略，所以在electron开发中，可以直接调接口。

# 搭建Electron环境
​```
mkdir electron-app
cd electron-app
npm init
cnpm i electron -g
cnpm i electron -S
​```
- mian.js 是electron的主线程，一般用于创建窗口。。。
- preload.js 是electron的渲染线程。。。
- 运行桌面应用：`electron .`

# 手动搭建Vue(装饰器)环境
​```
cnpm i webpack -D
cnpm i webpack-dev-server -D
cnpm i @babel/coo......
cnpm i vue-loader babel-load.....
cnpm i html-webpack-plugin ....
​```
​```
cnpm i vue vue-router vuex -S
cnpm i vue-property-decorator vuex-class -S
​```
- webpack.config.js 中配置入口、出口、loaders、plugins。。。
- babel.config.js 对babel进行若干配置，还要支持装饰器语法。。。
- vue装饰器编程范式，参考 src 目录。

# 环境运行

- 在election中区分开发和生产环境，使用到了`electron-is-dev`
- 运行项目时希望先启动vue本地服务，再启动桌面应用，使用到了`concurrently`

# Electorn打包

- 首先要对前端项目进行打包（前端项目打包的注意事项和普通web项目打包一致）
- 进一步打包electron项目（打包工具推荐使用 electorn-builder）
  - 打包步骤：https://github.com/electron-userland/electron-builder
  - 打包注意：对package.json文件进行各种配置，尤其"build"配置。
  - build配置参考：https://www.electron.build/configuration/configuration#configuration
```

# React Native

```
# 环境搭建

- 不建议使用 create-react-native-app
- 建议使用 react-native
​```
cnpm i react-native -g
react-native init MyApp
​```

# ReactNative简介

- 来自于 Facebook 这家公司
- 背后依赖于 React，所以react版本是多少，你就可以使用怎么的react语法。
- RN 本质上提供了一套移动端的UI（Widget）、移动布局样式规范、操作手机系统的API。
- RN一套代码，可以打包成android app、ios app，所以RN也是一个跨平台的APP技术。

# 从技术的角度提一下简历技巧

- 亮点（学历、专业、年龄、排版、求职方向）=>你是一个有潜力、很用心、很细心。
- 技术点（突出某一个技术栈，避免什么都会、技术点版本、开发工具）=>你是技术综合能力强、并且是一个比较专注的人。
- 项目点（对照你找的项目，把这个项目的功能点罗列出来，越多越多）=>功能难点、功能亮点

# ReactNative学习方法

- 文档教程：看react-native文档，这是最完整教程。
- 环境搭建：学习建议snack中敲代码；如果是真实开发建议用mac搭建原生环境。
- 开源代码：自已去社区中找RN的开源项目，研究代码结构（架构）。
- 引申借鉴：学会了RN，之后学Flutter也比较容易。（如果一定要建议，建议研究一下Flutter）


# 开发环境搭建

- 沙盒环境：使用 expo-cli创建项目，在手机安卓expo app，通过手机扫码进行运行和调试。
- 原生环境：要考虑是windows环境，还是mac环境。(以mac为便说明RN的开发环境搭建)
  - 开发和调试android应用：Node、JDK、Android Studio、Watchman
  - 开发和调试ios应用：Node、Watchman、Xcode(mac电脑上一个开发工具)和CocoaPods(包管理器)。

- expo工具介绍：
  - expo-cli 对国内用户不太友好，不建议使用。
  - snack：在线的expo环境，在这个网站可以编写RN代码。地址：https://snack.expo.dev/
  - 如何学习RN？一边阅读RN文档，一边在snake中进行在线编程。

- RN内置组件和原生（Android/IOS）关系，在公司中原生可以编写组件，给RN使用。
- RN语法基础，完全遵从React风格（类组件、函数式组件）。
- RN中表单也是单向绑定（受控组件）。
- RN常用的列表组件有 SessionList、FlatList，支持下拉刷新、触底加载等多种功能。
- 在RN样式，建议使用 Flex布局、百分比布局，样式单位默认就是 px。如果在样式层面需要做兼容性，要配合系统API来实现。
- 在RN中，不建议使用背景图片，建议使用 ImageBackground；普通图片使用 Image 组件。
- 在RN中有一个非常重要的合成事件 onPress，在 Button、Touch* 系列组件上使用。
- 动画使用 Animated 这个API。
- 在RN开发，并不是任意的js语法都支持，没必须刻意安装@babel来支持各种语法。
- RN官方推荐使用 fetch 进行网络编程，当然你可以使用 axios。
- 以下是常见的RN面试题：
  - 谈一谈你对RN的理解及其编程范式。
  - 你常用的RN第三方库有哪些？
  - RN中路由系统是怎么样的？
  - RN环境搭建。。。。
  - RN中如何实现混合开发？RN程序和H5之间如何通信？
  - RN项目你遇到的难点和挑战。。。。
  - RN项目的打包流程、上线流程。。。

# RN路由系统

- react-router-native (不建议使用)
- react-native-navigation（仅供参考）
- react-navigation（官方推荐）：https://reactnavigation.org/

- 入门使用 react-navigation
- 配置路由容器、底部Tabbar、配置Screen路由。
​```
import { NavigationContainer } from '@react-navigation/native'
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs'
const Tab = createBottomTabNavigator()
import { createNativeStackNavigator } from '@react-navigation/native-stack'
const Stack = createNativeStackNavigator()

const Home = () => (
  <Tab.Navigator>
    <Tab.Screen name='Home' component={Home} />
    <Tab.Screen name='Find' component={Find} />
  </Tab.Navigator>
)
const App = () => (
  <NavigationContainer>
    <Stack.Navigator>
      <Stack.Screen name='Index' component={TabBar} options={{title:'首页'}} />
      <Stack.Screen name='Login' component={Login} />
    </Stack.Navigator>
  </NavigationContainer>
)
​```
- 使用路由API：凡是被Screen修饰过的组件，其props上都有route路由信息、navigation路由API。
- 在最新的react-navigation(v6)，还可以使用 useNavigation、useRoute等路由Hooks进行编程。

# RN生态其它工具推荐

- 混合开发：react-native-webview
- 日期组件：react-native-datepicker 、react-native-calendars
- 设备信息：react-native-device-info
- ICON图标：react-native-vector-icons

- 温馨提示：社区中一些RN第三方包安装后，一般都要在ios目录进行链接操作`pod install`。

# Mac电脑调试ios App
- 在XCode中打开 RN 项目的 ios 目录、执行build编译。
- 在RN项目的ios目录下 `pod install` 链接ios原生依赖包。
- 在RN项目的根目录下 `npm run ios` 启动Xcode模拟器进行调试。

```

# testone 测试管理平台系统

```


四个模块：
测试用例管理：
	手工用例库：新建用例库（查看、删除、编辑用例库）
		用例库详情：测试用例、用例评审、测试计划
			测试用例：（列表模式、脑图模式）
				新建用例：富文本编辑器 wangeditor/editor
					（新建/编辑 用例信息(用例标题、步骤、前置条件、有效性、优先级类型、附件......)）、
					关联需求、
					关联缺陷、
					关联测试
				导入用例（excel导入、xmind导入）
				导出用例（excel文件导出、feature文件导出）、
				模块列表（树结构）（新建子模块、删除、重命名、移动）
			用例评审：新建评审（选择评审人、通知方法）、查看（选择用例、评审用例（通过、未通过））、删除、编辑
			测试计划：新建测试计划（选择负责人、通知方法）、查看（选择用例、设置结果（未测、成功、失败、重测、阻塞、跳过）、查看测试报告）、删除、编辑

    自动化用例库

测试任务：
	任务列表（增删改查）
		新建任务：直接新建（测试计划编排：选择测试类型：手工测试、终端自动化测试（终端-Android-云测、优测、单测）、选择被测产物（从蓝盾获取构建产物））

测试报告

测试配置
```

# 内审千里眼系统

```
首页模块：搜索框

小工具列表：

企业族谱、企业路径穿透、企业关系校验、企业位置关系、企业与员工关系、内部人员查询、外部人员查询、供应商利益冲突、供应商围标串标、部门合作风险、团伙关联

自定义小工具



企业详情页：

	合作信息：

		工商注册的基本信息 ：注册时间 、资本、参保人数、法人、地址、经营范围 、曾用名、营业期限 

		账户信息 ：首次登记时间  （在腾讯业务中第一次设立账号的时间 ）、登记行业 （业务准入时登记的行业和类目，如商户类目、广告推广行业等  ）、账户数量、关联公司数量、投放产品数量、处罚参数、是否加黑

		供应商信息 ：是否供应商 、是否三证合一 、中标/参标次数 、准入BG/类别/当前状态 

		合同信息 ：首次签订时间 、合同到期时间、 合同金额（付 ）、合同金额（收 ）、实付金额 、实收金额 、合同数量  、合作部门数量 

---

		业务信息 ：

			账户分布（个）（该公司账户在腾讯各业务的分布情况 ）、合同分布（份）（该公司合同在腾讯各部门的分布情况 ） 

		财务概况：交易类型分布 （epo/cost/upay的对外付款情况，基于费用类型分布 ）、付款部门分布 

		月结支出 、月结收入 

		企业产品信息 ：产品分布 个数、产品状态 

	关系图谱 ：当前公司的子公司、股东、任职的电话、证件号

	工商信息：

		工商注册信息：法定代表人 、注册金额 、实收资本 、注册时间 、信用代码 、参保人数 、组织机构代码 、所属省份 、注册号  、所属行业、 公司性质、检验日期 、

		高管信息 ：职位、姓名

		企业族谱 ：上下结构，股东（投资比例）、子公司（投资比例）

		股权信息 ：股东、持股金额、持股比例

		投资信息：投资公司、持股金额、持股比例

		工商风险扫描信息

		工商变更信息   

	风险信息： 

		风险标签分类（echarts）、业务处罚情况（echarts）

		公司关联风险图谱：当前公司与其他公司存在的关联信息

	关键事件 ：

		创办时间、第一次付款时间、第一份合同签订时间 、最近合同签订时间 、准入时间 

		关键数据 

		 干系人图谱 （左右结构）：企业主要人员:  法人、经理、董事、

								合同干系人 :  部门

								供应商干系人 ：部门

		历史参标信息







首页，由两部分，一个搜索框，一个小工具列表 ，搜索到公司姓名，点击之后就会跳转到企业详情页面，这个详情页面有五个页面：合作信息页面、关系图谱页面、工商信息页面、风险信息页面、关键事件页面

合作信息：

	有工商注册基本信息、

	合同信息、

	供应商信息、

 	业务信息（echarts 饼状图）：账户分布、合同分布

	财务概况（echarts 折线图）：月结收入、月结支出、

	产品信息 （echarts 饼状图）：产品分布、产品状态

关系图谱：这个图谱采用了 antv-g6 这一个图可视化引擎组件库，采用辐射布局（以一个点为中心，向四周辐射），以该公司为中心点，展示  子公司、股东、邮箱、电话、证件号等信息

工商信息：

	工商注册信息的详细信息

	高管信息

	股权信息

	投资信息

	企业族谱：紧凑树布局（ 根节点在中间，垂直对称布局 ），上面展示了 股东、下面展示了子公司

	工商变更信息

	法院案件  	

风险信息：

	风险标签分类（echarts 饼图）

	公司关联风险图谱 ：采用 辐射布局，以该公司为中心，展示了与其他公司关联的风险信息

关键事件 

	关键数据

	干系人图谱 ：紧凑树布局（根节点在中间，水平对称布局 ）：展示企业主要人员、合同干系人、供应商干系人、

	历史参标信息



小工具列表：

企业族谱、企业路径穿透、企业关系校验、企业位置关系、企业与员工关系、内部人员查询、外部人员查询、供应商利益冲突、供应商围标串标、部门合作风险、团伙关联

```

# 反舞弊业务系统

```
首页：

	快捷入口

	我的工作台：我的待办、我的已办

	公告通知

	帮助文档

	业务接口人

	相关咨询

个人中心模块：

	我的待办 ： 待办的审批申请 、待办的案件

	我的已办 ：已办的审批申请、已办的案件、已办的线索

信息查询模块：

线索管理模块 ：

	线索录入 ：线索录入 、提交，待审批通过后，立案，形成案件

	线索查询 :  线索列表

案件管理模块 ：

	案件查询 

		案件详情页 ：

			当前案件进度（立案、结案、关闭、归档）

			案件基本信息 ：案件编号、线索编号、案件类型、地区、时间、来源、名称、涉案BG、主办调查员 、协办调查员 、案发原因-控制缺陷 、案发原因-个人动机 、举报内容 、涉案金额 、挽回损失 、涉案部门  

			涉案违规人员：员工、证件信息、违规程度、违规类型、违规行为、涉案金额、认定金额、挽回金额

			涉案其他人员：员工 、证件信息、违规程度、违规类型、违规行为、涉案金额、认定金额、挽回金额

			涉案管理者：供应商名称、统一信用代码、合作状态

			涉案供应商、

			必要操作 ：

				人事征集

				调查报告

				结案报告

		案件编辑页 

		

	涉案主体查询 ：涉案供应商、涉案人员

	涉案物品查询 ：

	案件归档查询



名单管理模块：

	发文名单处理

	供应商处理

宣导培训模块：

	问卷查询

	培训查询

系统管理模块：

	公告管理

	邮件管理

	用户管理:

		用户查询

		添加用户

	角色管理：



反舞弊业务系统 ：为反舞弊调查组员工提供帮助

```

